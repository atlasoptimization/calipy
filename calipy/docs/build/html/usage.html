

<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Usage &#8212; calipy 0.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b849a4e9" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css?v=c92c1228" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=1c40f30e"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">calipy 0.5 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Usage</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="usage">
<h1>Usage<a class="headerlink" href="#usage" title="Permalink to this heading">¶</a></h1>
<section id="installation">
<span id="label-installation"></span><h2>Installation<a class="headerlink" href="#installation" title="Permalink to this heading">¶</a></h2>
<p>To use calipy, first install it using pip:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">(.venv)</span> <span class="gp">$ </span>pip install calipy
</pre></div>
</div>
</section>
<section id="basic-classes">
<h2>Basic classes<a class="headerlink" href="#basic-classes" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.base.CalipyNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.base.</span></span><span class="sig-name descname"><span class="pre">CalipyNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.base.CalipyNode" title="Permalink to this definition">¶</a></dt>
<dd><p>The CalipyNode class provides a comprehensive representation of the data 
flow and the dependencies between the nodes.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.base.NodeStructure">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.base.</span></span><span class="sig-name descname"><span class="pre">NodeStructure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.base.NodeStructure" title="Permalink to this definition">¶</a></dt>
<dd><p>NodeStructure class is basis for defining batch_shapes, event_shapes, and plate
configurations for a CalipyNode object. Provides functionality for attribute-
like access and automated construction. Each object of NodeStructure class has
attributes description, shapes, plates, plate_stacks.
Methods include set_shape, set_plate_stack, update, print_shapes_and_plates,
and generate_template which can be used to either set the properties of a
newly instantiated object node_structure = NodeStructure() or to modify an
existing object by updating it. NodeStructure objects are central for instantiating
CalipyNode objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> (<em>list</em>) – optional arguments (can be None)</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – dictionary containing keyword arguments (can be None)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Empty Instance of the NodeStructure class to be populated by info
via the set_shape and set_plate_stack methods.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.base.NodeStructure" title="calipy.core.base.NodeStructure">NodeStructure</a></p>
</dd>
</dl>
<p>Example usage: Run line by line to investigate Class</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up NodeStructure -----------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># i) Imports and definitions</span>
<span class="kn">import</span> <span class="nn">calipy</span>
<span class="kn">from</span> <span class="nn">calipy.core.base</span> <span class="kn">import</span> <span class="n">NodeStructure</span>
<span class="kn">from</span> <span class="nn">calipy.core.effects</span> <span class="kn">import</span> <span class="n">UnknownParameter</span>
<span class="c1">#        </span>
<span class="c1"># Specify some dimensions: param_dims, batch_dims feature in the template nodestructure</span>
<span class="c1"># UnknownParameter.default_nodestructure while event_dims does not.</span>
<span class="n">param_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;param_dim&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="n">batch_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;batch_dim&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">])</span>
<span class="n">event_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;event_dim&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># ii) Set up generic node_structure</span>
<span class="c1"># ... either directly via arguments:</span>
<span class="n">node_structure</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">()</span>
<span class="n">node_structure</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">param_dims</span> <span class="o">=</span> <span class="n">param_dims</span><span class="p">,</span> 
                        <span class="n">batch_dims</span> <span class="o">=</span> <span class="n">batch_dims</span><span class="p">,</span> 
                        <span class="n">event_dims</span> <span class="o">=</span> <span class="n">event_dims</span><span class="p">)</span>
<span class="n">node_structure</span><span class="o">.</span><span class="n">set_dim_descriptions</span><span class="p">(</span><span class="n">param_dims</span> <span class="o">=</span> <span class="s1">&#39;parameter dimensions&#39;</span><span class="p">,</span>
                                    <span class="n">batch_dims</span> <span class="o">=</span> <span class="s1">&#39;batch dimensions&#39;</span><span class="p">,</span>
                                    <span class="n">event_dims</span> <span class="o">=</span> <span class="s1">&#39;event_dimensions&#39;</span><span class="p">)</span>
<span class="c1"># ... or by passing dictionaries</span>
<span class="n">node_structure</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;param_dims&#39;</span> <span class="p">:</span> <span class="n">param_dims</span><span class="p">,</span>
                           <span class="s1">&#39;batch_dims&#39;</span> <span class="p">:</span> <span class="n">batch_dims</span><span class="p">})</span>
<span class="n">node_structure</span><span class="o">.</span><span class="n">set_dim_descriptions</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;param_dims&#39;</span> <span class="p">:</span> <span class="s1">&#39;parameter dimensions&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;batch_dims&#39;</span> <span class="p">:</span> <span class="s1">&#39;batch dimensions&#39;</span><span class="p">})</span>

<span class="c1"># iii) Set up node structure tied to specific class</span>
<span class="n">param_ns_1</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">(</span><span class="n">UnknownParameter</span><span class="p">)</span>
<span class="n">param_ns_2</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">(</span><span class="n">UnknownParameter</span><span class="p">)</span>
<span class="n">param_ns_3</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">(</span><span class="n">UnknownParameter</span><span class="p">)</span>


<span class="c1"># Investigate NodeStructure -------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># The set_dims method inherits an updated docstring and autocompletion</span>
<span class="nb">print</span><span class="p">(</span><span class="n">param_ns_1</span><span class="p">)</span>   <span class="c1"># Shows the default_nodestructure of UnknownParamter</span>
<span class="n">help</span><span class="p">(</span><span class="n">param_ns_1</span><span class="o">.</span><span class="n">set_dims</span><span class="p">)</span>   <span class="c1"># Shows that param_dims, batch_dims are arguments</span>

<span class="c1"># The initialized node structure can be updated by inheritance or by directly setting</span>
<span class="c1"># dimensions. It errors out, if a dimension is specified that is not specified</span>
<span class="c1"># by the default_nodestructure</span>
<span class="c1">#</span>
<span class="c1"># Create nodestructure with custom param_dims and batch_dims</span>
<span class="n">param_ns_1</span><span class="o">.</span><span class="n">inherit_common_dims</span><span class="p">(</span><span class="n">node_structure</span><span class="p">)</span>  
<span class="nb">print</span><span class="p">(</span><span class="n">param_ns_1</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1"># Create nodestructure with custom param_dims and default batch_dims</span>
<span class="n">param_ns_2</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">param_dims</span> <span class="o">=</span> <span class="n">param_dims</span><span class="p">)</span> 
<span class="nb">print</span><span class="p">(</span><span class="n">param_ns_2</span><span class="p">)</span>   
<span class="c1">#</span>
<span class="c1"># This errors out as it should: param_ns_3.set_dims(event_dims = event_dims)         </span>
<span class="c1">#</span>
<span class="c1"># iv) Investigate NodeStructure objects</span>
<span class="n">param_ns_1</span><span class="o">.</span><span class="n">dims</span>
<span class="n">param_ns_1</span><span class="o">.</span><span class="n">dim_names</span>
<span class="n">param_ns_1</span><span class="o">.</span><span class="n">dim_descriptions</span>
<span class="n">param_ns_1</span><span class="o">.</span><span class="n">node_cls</span>
<span class="c1">#</span>
<span class="c1"># It is possible to build the code that, if executed, generates the nodestructure</span>
<span class="n">param_ns_1</span><span class="o">.</span><span class="n">generate_template</span><span class="p">()</span>

<span class="c1"># v) Build and check nodestructure via class methods</span>
<span class="n">empty_node_structure</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">()</span>
<span class="n">UnknownParameter</span><span class="o">.</span><span class="n">check_node_structure</span><span class="p">(</span><span class="n">empty_node_structure</span><span class="p">)</span>
<span class="n">UnknownParameter</span><span class="o">.</span><span class="n">check_node_structure</span><span class="p">(</span><span class="n">param_ns_1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.base.CalipyProbModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.base.</span></span><span class="sig-name descname"><span class="pre">CalipyProbModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.base.CalipyProbModel" title="Permalink to this definition">¶</a></dt>
<dd><p>CalipyProbModel is an abstract base class that integrates the model, guide, and training components 
for probabilistic models within the Calipy framework. It serves as the foundation for building and 
training probabilistic models by providing methods to define the model, guide, and manage optimization
and training procedures.</p>
<p>This class is designed to be subclassed, where users define the specific <cite>model</cite> and <cite>guide</cite> methods 
based on their probabilistic model requirements. The <cite>train</cite> method facilitates the training process 
using stochastic variational inference (SVI) by interacting with Pyro’s SVI module.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>str</em><em>, </em><em>optional</em>) – An optional string representing the type of the model. This can be used to categorize 
or identify the model within larger workflows.</p></li>
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>optional</em>) – An optional string representing the name of the model. This name is useful for tracking 
and referencing the model within a project or experiment.</p></li>
<li><p><strong>info</strong> (<em>dict</em><em>, </em><em>optional</em>) – An optional dictionary containing additional information about the model, such as 
metadata or configuration details.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the CalipyProbModel class.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.base.CalipyProbModel" title="calipy.core.base.CalipyProbModel">CalipyProbModel</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Architecture of CalipyProbModel objects is as below</span>
<span class="k">class</span> <span class="nc">MyProbModel</span><span class="p">(</span><span class="n">CalipyProbModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Integrate nodes or parameters specific to the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">some_param</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">param</span><span class="p">(</span><span class="s2">&quot;some_param&quot;</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">output_data</span><span class="p">):</span>
        <span class="c1"># Define the generative model</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">guide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">output_data</span><span class="p">):</span>
        <span class="c1"># Define the guide (variational distribution)</span>
        <span class="k">pass</span>

<span class="n">prob_model</span> <span class="o">=</span> <span class="n">MyProbModel</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;example_model&quot;</span><span class="p">)</span>
<span class="n">prob_model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">output_data</span><span class="p">,</span> <span class="n">optim_opts</span><span class="p">)</span>


<span class="c1"># Here is a fuly worked example:</span>

<span class="c1"># i) Imports and definitions</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">pyro</span>
<span class="kn">import</span> <span class="nn">calipy</span>
<span class="kn">from</span> <span class="nn">calipy.core.utils</span> <span class="kn">import</span> <span class="n">dim_assignment</span>
<span class="kn">from</span> <span class="nn">calipy.core.data</span> <span class="kn">import</span> <span class="n">DataTuple</span>
<span class="kn">from</span> <span class="nn">calipy.core.tensor</span> <span class="kn">import</span> <span class="n">CalipyTensor</span>
<span class="kn">from</span> <span class="nn">calipy.core.effects</span> <span class="kn">import</span> <span class="n">UnknownParameter</span><span class="p">,</span> <span class="n">NoiseAddition</span>
<span class="kn">from</span> <span class="nn">calipy.core.base</span> <span class="kn">import</span> <span class="n">NodeStructure</span><span class="p">,</span> <span class="n">CalipyProbModel</span>

<span class="c1"># ii) Set up unknown mean parameter</span>
<span class="n">batch_dims_param</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd_p1&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">])</span>
<span class="n">param_dims_param</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;pd_p1&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">param_ns</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">(</span><span class="n">UnknownParameter</span><span class="p">)</span>
<span class="n">param_ns</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">param_dims</span> <span class="o">=</span> <span class="n">param_dims_param</span><span class="p">,</span> <span class="n">batch_dims</span> <span class="o">=</span> <span class="n">batch_dims_param</span><span class="p">)</span>
<span class="n">mu_object</span> <span class="o">=</span> <span class="n">UnknownParameter</span><span class="p">(</span><span class="n">param_ns</span><span class="p">)</span>

<span class="c1"># iii) Set up noise addition</span>
<span class="n">batch_dims_noise</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd_n1&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_n2&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">event_dims_noise</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;ed_n1&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">noise_ns</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">(</span><span class="n">NoiseAddition</span><span class="p">)</span>
<span class="n">noise_ns</span><span class="o">.</span><span class="n">set_dims</span><span class="p">(</span><span class="n">batch_dims</span> <span class="o">=</span> <span class="n">batch_dims_noise</span><span class="p">,</span> <span class="n">event_dims</span> <span class="o">=</span> <span class="n">event_dims_noise</span><span class="p">)</span>
<span class="n">noise_object</span> <span class="o">=</span> <span class="n">NoiseAddition</span><span class="p">(</span><span class="n">noise_ns</span><span class="p">)</span>

<span class="n">sigma</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">batch_dims_noise</span><span class="o">.</span><span class="n">sizes</span><span class="p">)</span>

<span class="c1"># iv) Simulate some data</span>
<span class="n">mu_true</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">5.0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="n">sigma_true</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">data_tensor</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">loc</span> <span class="o">=</span> <span class="n">mu_true</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">sigma_true</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">([</span><span class="mi">10</span><span class="p">])</span> 
<span class="n">data_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_tensor</span><span class="p">,</span> <span class="n">batch_dims_noise</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">([</span><span class="s1">&#39;sample&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">data_cp</span><span class="p">])</span>

<span class="c1"># v) Define ProbModel</span>
<span class="k">class</span> <span class="nc">MyProbModel</span><span class="p">(</span><span class="n">CalipyProbModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_vars</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">observations</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Define the generative model</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">mu_object</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
        <span class="n">input_vars</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">([</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;standard_deviation&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">])</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">noise_object</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">observations</span> <span class="o">=</span> <span class="n">observations</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sample</span>

    <span class="k">def</span> <span class="nf">guide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_vars</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">observations</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Define the guide (variational distribution)</span>
        <span class="k">pass</span>

<span class="c1"># vi) Inference</span>
<span class="n">prob_model</span> <span class="o">=</span> <span class="n">MyProbModel</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;example_model&quot;</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">prob_model</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">observations</span> <span class="o">=</span> <span class="n">data</span><span class="p">)</span>
<span class="n">optim_opts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;n_steps&#39;</span> <span class="p">:</span> <span class="mi">2000</span><span class="p">,</span> <span class="s1">&#39;learning_rate&#39;</span> <span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>
<span class="n">prob_model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">optim_opts</span> <span class="o">=</span> <span class="n">optim_opts</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="effect-classes">
<h2>Effect classes<a class="headerlink" href="#effect-classes" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.effects.CalipyEffect">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.effects.</span></span><span class="sig-name descname"><span class="pre">CalipyEffect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.effects.CalipyEffect" title="Permalink to this definition">¶</a></dt>
<dd><p>The CalipyEffect class provides a comprehensive representation of a specific 
effect. It is named, explained, and referenced in the effect description. The
effect is incorporated as a differentiable function based on torch. This function
can depend on known parameters, unknown parameters, and random variables. Known 
parameters have to be provided during invocation of the effect. During training,
unknown parameters and the posterior density of the random variables is inferred.
This requires providing a unique name, a prior distribution, and a variational
distribution for the random variables.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.effects.CalipyQuantity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.effects.</span></span><span class="sig-name descname"><span class="pre">CalipyQuantity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.effects.CalipyQuantity" title="Permalink to this definition">¶</a></dt>
<dd><p>The CalipyQuantity class provides a comprehensive representation of a specific 
quantity used in the construction of a CalipyEffect object. This could be a
known parameter, an unknown parameter, or a random variable. This quantity
is named, explained, and referenced in the quantity description. Quantities
are incorporated into the differentiable function that define the CalipyEffect
forward pass. Each quantity is subservient to an effect and gets a unique id
that reflects this, quantities are local and cannot be shared between effects.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.effects.UnknownParameter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.effects.</span></span><span class="sig-name descname"><span class="pre">UnknownParameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_structure</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Real()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.effects.UnknownParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>UnknownParameter is a subclass of CalipyQuantity that produces an object whose
forward() method produces a parameter that is subject to inference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_structure</strong> (<a class="reference internal" href="#calipy.core.base.NodeStructure" title="calipy.core.base.NodeStructure"><em>NodeStructure</em></a>) – Instance of NodeStructure that determines the internal
structure (shapes, plate_stacks, plates, aux_data) completely.</p></li>
<li><p><strong>constraint</strong> (<em>pyro.distributions.constraints.Constraint</em>) – Pyro constraint that constrains the parameter of a distribution
to lie in a pre-defined subspace of R^n like e.g. simplex, positive, …</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Instance of the UnknownParameter class built on the basis of node_structure</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.effects.UnknownParameter" title="calipy.core.effects.UnknownParameter">UnknownParameter</a> (subclass of CalipyQuantity subclass of <a class="reference internal" href="#calipy.core.base.CalipyNode" title="calipy.core.base.CalipyNode">CalipyNode</a>)</p>
</dd>
</dl>
<p>Example usage: Run line by line to investigate Class</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Investigate 2D bias tensor -------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># i) Imports and definitions</span>
<span class="kn">import</span> <span class="nn">calipy</span>
<span class="kn">from</span> <span class="nn">calipy.core.base</span> <span class="kn">import</span> <span class="n">NodeStructure</span>
<span class="kn">from</span> <span class="nn">calipy.core.effects</span> <span class="kn">import</span> <span class="n">UnknownParameter</span>
<span class="n">node_structure</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">(</span><span class="n">UnknownParameter</span><span class="p">)</span>
<span class="n">bias_object</span> <span class="o">=</span> <span class="n">UnknownParameter</span><span class="p">(</span><span class="n">node_structure</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;tutorial&#39;</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1"># ii) Produce bias value</span>
<span class="n">bias</span> <span class="o">=</span> <span class="n">bias_object</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="c1">#</span>
<span class="c1"># iii) Investigate object</span>
<span class="n">bias_object</span><span class="o">.</span><span class="n">dtype_chain</span>
<span class="n">bias_object</span><span class="o">.</span><span class="n">id</span>
<span class="n">bias_object</span><span class="o">.</span><span class="n">node_structure</span>
<span class="n">bias_object</span><span class="o">.</span><span class="n">node_structure</span><span class="o">.</span><span class="n">dims</span>
<span class="n">render_1</span> <span class="o">=</span> <span class="n">bias_object</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
<span class="n">render_1</span>
<span class="n">render_2</span> <span class="o">=</span> <span class="n">bias_object</span><span class="o">.</span><span class="n">render_comp_graph</span><span class="p">()</span>
<span class="n">render_2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.effects.UnknownVariance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.effects.</span></span><span class="sig-name descname"><span class="pre">UnknownVariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_structure</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.effects.UnknownVariance" title="Permalink to this definition">¶</a></dt>
<dd><p>UnknownVariance is a subclass of UnknownParameter that includes a positivity constraint. UnknownParameter is a subclass of CalipyQuantity that produces an object whose
forward() method produces a parameter that is subject to inference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_structure</strong> (<a class="reference internal" href="#calipy.core.base.NodeStructure" title="calipy.core.base.NodeStructure"><em>NodeStructure</em></a>) – Instance of NodeStructure that determines the internal
structure (shapes, plate_stacks, plates, aux_data) completely.</p></li>
<li><p><strong>constraint</strong> (<em>pyro.distributions.constraints.Constraint</em>) – Pyro constraint that constrains the parameter of a distribution
to lie in a pre-defined subspace of R^n like e.g. simplex, positive, …</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Instance of the UnknownParameter class built on the basis of node_structure</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.effects.UnknownParameter" title="calipy.core.effects.UnknownParameter">UnknownParameter</a> (subclass of CalipyQuantity subclass of <a class="reference internal" href="#calipy.core.base.CalipyNode" title="calipy.core.base.CalipyNode">CalipyNode</a>)</p>
</dd>
</dl>
<p>Example usage: Run line by line to investigate Class</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Investigate 2D bias tensor -------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># i) Imports and definitions</span>
<span class="kn">import</span> <span class="nn">calipy</span>
<span class="kn">from</span> <span class="nn">calipy.core.base</span> <span class="kn">import</span> <span class="n">NodeStructure</span>
<span class="kn">from</span> <span class="nn">calipy.core.effects</span> <span class="kn">import</span> <span class="n">UnknownParameter</span>
<span class="n">node_structure</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">(</span><span class="n">UnknownParameter</span><span class="p">)</span>
<span class="n">bias_object</span> <span class="o">=</span> <span class="n">UnknownParameter</span><span class="p">(</span><span class="n">node_structure</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;tutorial&#39;</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1"># ii) Produce bias value</span>
<span class="n">bias</span> <span class="o">=</span> <span class="n">bias_object</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
<span class="c1">#</span>
<span class="c1"># iii) Investigate object</span>
<span class="n">bias_object</span><span class="o">.</span><span class="n">dtype_chain</span>
<span class="n">bias_object</span><span class="o">.</span><span class="n">id</span>
<span class="n">bias_object</span><span class="o">.</span><span class="n">node_structure</span>
<span class="n">bias_object</span><span class="o">.</span><span class="n">node_structure</span><span class="o">.</span><span class="n">dims</span>
<span class="n">render_1</span> <span class="o">=</span> <span class="n">bias_object</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
<span class="n">render_1</span>
<span class="n">render_2</span> <span class="o">=</span> <span class="n">bias_object</span><span class="o">.</span><span class="n">render_comp_graph</span><span class="p">()</span>
<span class="n">render_2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.effects.NoiseAddition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.effects.</span></span><span class="sig-name descname"><span class="pre">NoiseAddition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_structure</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.effects.NoiseAddition" title="Permalink to this definition">¶</a></dt>
<dd><p>NoiseAddition is a subclass of CalipyEffect that produces an object whose
forward() method emulates uncorrelated noise being added to an input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node_structure</strong> (<a class="reference internal" href="#calipy.core.base.NodeStructure" title="calipy.core.base.NodeStructure"><em>NodeStructure</em></a>) – Instance of NodeStructure that determines the internal
structure (shapes, plate_stacks, plates, aux_data) completely.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Instance of the NoiseAddition class built on the basis of node_structure</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.effects.NoiseAddition" title="calipy.core.effects.NoiseAddition">NoiseAddition</a> (subclass of CalipyEffect subclass of <a class="reference internal" href="#calipy.core.base.CalipyNode" title="calipy.core.base.CalipyNode">CalipyNode</a>)</p>
</dd>
</dl>
<p>Example usage: Run line by line to investigate Class</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Investigate 2D noise ------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># i) Imports and definitions</span>
<span class="kn">import</span> <span class="nn">calipy</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">calipy.core.base</span> <span class="kn">import</span> <span class="n">NodeStructure</span>
<span class="kn">from</span> <span class="nn">calipy.core.tensor</span> <span class="kn">import</span> <span class="n">CalipyTensor</span>
<span class="kn">from</span> <span class="nn">calipy.core.effects</span> <span class="kn">import</span> <span class="n">NoiseAddition</span>

<span class="c1"># ii) Invoke and investigate class</span>
<span class="n">help</span><span class="p">(</span><span class="n">NoiseAddition</span><span class="p">)</span>
<span class="n">NoiseAddition</span><span class="o">.</span><span class="n">mro</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">NoiseAddition</span><span class="o">.</span><span class="n">input_vars_schema</span><span class="p">)</span>

<span class="c1"># iii) Instantiate object</span>
<span class="n">noise_ns</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">(</span><span class="n">NoiseAddition</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">noise_ns</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">noise_ns</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
<span class="n">noise_object</span> <span class="o">=</span> <span class="n">NoiseAddition</span><span class="p">(</span><span class="n">noise_ns</span><span class="p">)</span>

<span class="c1"># iv) Create arguments</span>
<span class="n">noise_dims</span> <span class="o">=</span> <span class="n">noise_ns</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="s1">&#39;batch_dims&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">noise_ns</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="s1">&#39;event_dims&#39;</span><span class="p">]</span>
<span class="n">mu</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">noise_dims</span><span class="o">.</span><span class="n">sizes</span><span class="p">),</span> <span class="n">noise_dims</span><span class="p">,</span> <span class="s1">&#39;mu&#39;</span><span class="p">)</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">noise_dims</span><span class="o">.</span><span class="n">sizes</span><span class="p">),</span> <span class="n">noise_dims</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">)</span>
<span class="n">noise_input_vars</span> <span class="o">=</span> <span class="n">NoiseAddition</span><span class="o">.</span><span class="n">create_input_vars</span><span class="p">(</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mu</span><span class="p">,</span> <span class="n">standard_deviation</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">noise_input_vars</span><span class="p">)</span>

<span class="c1"># v) Pass forward</span>
<span class="n">noisy_output</span> <span class="o">=</span> <span class="n">noise_object</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">input_vars</span> <span class="o">=</span> <span class="n">noise_input_vars</span><span class="p">,</span> 
                                    <span class="n">observations</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                                    <span class="n">subsample_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">noisy_output</span>
<span class="n">noisy_output</span><span class="o">.</span><span class="n">dims</span>
<span class="n">help</span><span class="p">(</span><span class="n">noisy_output</span><span class="p">)</span>

<span class="c1"># vi) Investigate object further</span>
<span class="n">noise_object</span><span class="o">.</span><span class="n">dtype_chain</span>
<span class="n">noise_object</span><span class="o">.</span><span class="n">id</span>
<span class="n">render_1</span> <span class="o">=</span> <span class="n">noise_object</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">noise_input_vars</span><span class="p">)</span>
<span class="n">render_1</span>
<span class="n">render_2</span> <span class="o">=</span> <span class="n">noise_object</span><span class="o">.</span><span class="n">render_comp_graph</span><span class="p">(</span><span class="n">noise_input_vars</span><span class="p">)</span>
<span class="n">render_2</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="utility-classes-and-functions">
<h2>Utility classes and functions<a class="headerlink" href="#utility-classes-and-functions" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.utils.multi_unsqueeze">
<span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">multi_unsqueeze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.multi_unsqueeze" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.utils.robust_meshgrid">
<span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">robust_meshgrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indexing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ij'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.robust_meshgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensures that meshgrid also works for empty inputs [] of sizes.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.utils.ensure_tuple">
<span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">ensure_tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.ensure_tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensures the input is a tuple. Leaves tuples unchanged. Wraps non-iterables into a tuple.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.utils.get_params">
<span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">get_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.get_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.utils.format_mro">
<span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">format_mro</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.format_mro" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.utils.check_schema">
<span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">check_schema</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">calipy_dict_obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">required_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optional_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.check_schema" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Example schema validation function:</dt><dd><ul class="simple">
<li><p>required_keys: list of keys that must exist</p></li>
<li><p>optional_keys: list of recognized but optional keys</p></li>
</ul>
</dd>
</dl>
<p>Raises ValueError if some required keys are missing.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.utils.dim_assignment">
<span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">dim_assignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_sizes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim_descriptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.dim_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>dim_assignment dynamically assigns dimension objects to names and returns them as a DimTuple.</p>
<p>This function creates <cite>DimTuple</cite> objects using the specified sizees in <cite>dim_sizes</cite> and assigns them to the
names provided in <cite>dim_names</cite>. The function validates that the dimension sizes are positive integers
or None (for unbound dimensions) and that the dimension names are valid Python identifiers. If only
one name is provided with multiple shapes, the name is extended by indices (e.g., ‘batch’ -&gt; ‘batch_1’,
‘batch_2’, etc.). The function then returns a DimTuple of the created <cite>CalipyDim</cite> objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim_names</strong> (<em>list</em><em> of </em><em>str</em>) – A list of strings representing the variable names to assign to each dimension. 
These names must be valid Python identifiers. If only one name is provided and multiple shapes,
the name will be broadcast with indices (e.g., [‘batch’] -&gt; [‘batch_1’, ‘batch_2’, …]).</p></li>
<li><p><strong>dim_sizes</strong> (<em>list</em><em> of </em><em>int</em><em> or </em><em>None</em>) – A list of nonnegative integers or None representing the sizes of each dimension; 
None indicates an unbound dimension; a value of 0 indicates an empty dimension</p></li>
<li><p><strong>dim_descriptions</strong> – A list of descriptions describing each dimension; 
None indicates absence of descriptions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DimTuple containing the <cite>CalipyDim</cite> objects assigned to the names in <cite>dim_names</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.utils.DimTuple" title="calipy.core.utils.DimTuple">DimTuple</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;batch_dim_1&#39;</span><span class="p">,</span> <span class="s1">&#39;batch_dim_2&#39;</span><span class="p">]</span>
<span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">dim_tuple</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">)</span>

<span class="c1"># Access the dimensions</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dim_tuple</span><span class="p">)</span>  <span class="c1"># Outputs: (batch_dim_1, batch_dim_2)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dim_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>  <span class="c1"># Outputs: 10</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dim_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>  <span class="c1"># Outputs: 5</span>

<span class="c1"># Example with broadcasting</span>
<span class="n">dim_tuple</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;batch&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dim_tuple</span><span class="p">)</span>  <span class="c1"># Outputs: (batch_1, batch_2)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dim_tuple</span><span class="o">.</span><span class="n">sizes</span><span class="p">)</span>  <span class="c1"># Outputs: [5,2]</span>

<span class="c1"># Example with bound and unbound dims</span>
<span class="n">dim_tuple</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;batch_dim_1&#39;</span><span class="p">,</span> <span class="s1">&#39;batch_dim_2&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="n">dim_tuple</span><span class="o">.</span><span class="n">sizes</span>
<span class="n">dim_tuple</span><span class="o">.</span><span class="n">filter_bound</span><span class="p">()</span>
<span class="n">dim_tuple</span><span class="o">.</span><span class="n">filter_unbound</span><span class="p">()</span>

<span class="c1"># Example with a dimension skipped</span>
<span class="n">dim_tuple</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dim_tuple</span><span class="p">)</span>  <span class="c1"># Outputs: DimTuple(())</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.utils.generate_trivial_dims">
<span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">generate_trivial_dims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ndim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.generate_trivial_dims" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.utils.CalipyDim">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">CalipyDim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">description</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.CalipyDim" title="Permalink to this definition">¶</a></dt>
<dd><p>CalipyDim class contains information useful to manage dimensions and is
the prime ingredient to DimTuple class which implements arithmentics on 
dimensions. When initialized, it represents a dim primarily as a name and
attaches a size to it - either a nonnegative integer number or None which
represents the size of the dim bein undefined. Furthermore, a description
of the dim can be provided.
CalipyDim objects can be bound to tensors by their as_torchdim attribute 
which converts accesses a representation in terms of functorch.dim Dim objects
that allows indexing of tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – A string representing the name by which the dimension is to be identified</p></li>
<li><p><strong>size</strong> (<em>int</em><em> or </em><em>None</em>) – A nonnegative integer or None representing the size of this dimension; 
None indicates an unbound dimension; a value of 0 indicates an empty dimension</p></li>
<li><p><strong>description</strong> (<em>str</em><em> or </em><em>None</em>) – A description describing this dimension; 
None indicates absence of description.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A CalipyDim object containing names, size, description of a dimension</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.utils.CalipyDim" title="calipy.core.utils.CalipyDim">CalipyDim</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Single dimension properties</span>
<span class="n">bd_1</span> <span class="o">=</span> <span class="n">CalipyDim</span><span class="p">(</span><span class="s1">&#39;bd_1&#39;</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;batch dimension 1&#39;</span><span class="p">)</span>
<span class="n">bd_2</span> <span class="o">=</span> <span class="n">CalipyDim</span><span class="p">(</span><span class="s1">&#39;bd_2&#39;</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;batch dimension 2&#39;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">A</span><span class="p">[</span><span class="n">bd_1</span><span class="o">.</span><span class="n">torchdim</span><span class="p">,</span> <span class="n">bd_2</span><span class="o">.</span><span class="n">torchdim</span><span class="p">]</span>

<span class="c1"># Typical use case with dim_assignment</span>
<span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;d1&#39;</span><span class="p">,</span> <span class="s1">&#39;d2&#39;</span><span class="p">]</span>
<span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">dim_tuple</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">)</span>
<span class="n">dim_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1"># Is CalipyDim d1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.utils.TorchdimTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">TorchdimTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">superior_dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.TorchdimTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>TorchdimTuple is a subclass of the Tuple class that allows esy handling
of tuples build from functorchdim.dim.Dim objects. These tuples occur in the
DimTuple class, which is the main class to represent dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_tuple</strong> (<em>tuple</em><em> of </em><em>functorch.dim.Dim objects</em>) – A tuple of dimensions to be managed by TorchdimTuple.</p></li>
<li><p><strong>superior_dims</strong> (<em>DimTuple object</em>) – DimTuple object containing CalipyDim objects providing
further info on the torchdims in the TorchdimTuple object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of TorchdimTuple containing the dimension objects.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.utils.TorchdimTuple" title="calipy.core.utils.TorchdimTuple">TorchdimTuple</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create dimensions</span>
<span class="p">(</span><span class="n">bd</span><span class="p">,</span><span class="n">ed</span><span class="p">)</span> <span class="o">=</span> <span class="n">dims</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">torchdim_tuple</span> <span class="o">=</span> <span class="n">TorchdimTuple</span><span class="p">((</span><span class="n">bd</span><span class="p">,</span><span class="n">ed</span><span class="p">))</span>
<span class="n">torchdim_tuple</span><span class="o">.</span><span class="n">sizes</span>

<span class="c1"># Bind dimensions</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">A_named</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">torchdim_tuple</span><span class="p">]</span>
<span class="n">torchdim_tuple</span><span class="o">.</span><span class="n">sizes</span>

<span class="c1"># When being built from DimTuple, inherit info</span>
<span class="n">batch_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bd_1&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_2&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="n">event_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ed_1&#39;</span><span class="p">])</span>
<span class="n">full_dims</span> <span class="o">=</span> <span class="n">batch_dims</span> <span class="o">+</span> <span class="n">event_dims</span>
<span class="n">full_torchdims</span> <span class="o">=</span> <span class="n">full_dims</span><span class="o">.</span><span class="n">build_torchdims</span><span class="p">()</span>
<span class="n">full_torchdims</span><span class="o">.</span><span class="n">sizes</span>
<span class="n">full_torchdims</span><span class="o">.</span><span class="n">names</span>

<span class="c1"># Also allow for string-based and dim-based indexing</span>
<span class="n">full_torchdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">full_torchdims</span><span class="p">[[</span><span class="s1">&#39;bd_1&#39;</span><span class="p">]]</span>
<span class="n">full_torchdims</span><span class="p">[</span><span class="n">batch_dims</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
<span class="n">full_torchdims</span><span class="p">[</span><span class="n">batch_dims</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.utils.DimTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.utils.</span></span><span class="sig-name descname"><span class="pre">DimTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.utils.DimTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>DimTuple is a custom subclass of Python’s <cite>tuple</cite> designed to manage and manipulate tuples of 
dimension objects, such as those from CalipyDim. This class provides enhanced functionality 
specific to dimensions, allowing users to bind sizes, filter bound or unbound dimensions, 
and perform other operations tailored to the handling of dimension objects.</p>
<p>This class offers methods to bind dimension sizes selectively, retrieve sizes, and check 
whether dimensions are bound or unbound. Additionally, DimTuple supports tuple-like operations 
such as concatenation and repetition, while ensuring that the results remain within the DimTuple 
structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_tuple</strong> (<em>tuple</em><em> of </em><em>Dim</em>) – A tuple of dimension objects to be managed by DimTuple.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of DimTuple containing the dimension objects.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.utils.DimTuple" title="calipy.core.utils.DimTuple">DimTuple</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create dimensions</span>
<span class="n">bd_1</span> <span class="o">=</span> <span class="n">CalipyDim</span><span class="p">(</span><span class="s1">&#39;bd_1&#39;</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">bd_2</span> <span class="o">=</span> <span class="n">CalipyDim</span><span class="p">(</span><span class="s1">&#39;bd_2&#39;</span><span class="p">)</span>
<span class="n">ed_1</span> <span class="o">=</span> <span class="n">CalipyDim</span><span class="p">(</span><span class="s1">&#39;ed_1&#39;</span><span class="p">)</span>

<span class="c1"># Initialize DimTuples</span>
<span class="n">batch_dims</span> <span class="o">=</span> <span class="n">DimTuple</span><span class="p">((</span><span class="n">bd_1</span><span class="p">,</span> <span class="n">bd_2</span><span class="p">))</span>
<span class="n">event_dims</span> <span class="o">=</span> <span class="n">DimTuple</span><span class="p">((</span><span class="n">ed_1</span><span class="p">,))</span>

<span class="c1"># Equivalent command</span>
<span class="n">batch_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bd_1&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_2&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="n">event_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ed_1&#39;</span><span class="p">])</span>

<span class="c1"># Check sizes, names, properties</span>
<span class="n">batch_dims</span><span class="o">.</span><span class="n">names</span>
<span class="n">batch_dims</span><span class="o">.</span><span class="n">sizes</span>
<span class="n">batch_dims</span><span class="o">.</span><span class="n">filter_bound</span><span class="p">()</span>
<span class="n">batch_dims</span><span class="o">.</span><span class="n">filter_unbound</span><span class="p">()</span>

<span class="c1"># Extract info</span>
<span class="n">batch_dims</span><span class="o">.</span><span class="n">find_indices</span><span class="p">([</span><span class="s1">&#39;bd_2&#39;</span><span class="p">])</span>
<span class="n">batch_dims</span><span class="o">.</span><span class="n">find_relative_index</span><span class="p">(</span><span class="s1">&#39;bd_1&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_2&#39;</span><span class="p">)</span>
<span class="n">batch_dict</span> <span class="o">=</span> <span class="n">batch_dims</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

<span class="c1"># Change sizes for some dimensions</span>
<span class="n">bound_dims</span> <span class="o">=</span> <span class="n">batch_dims</span><span class="o">.</span><span class="n">bind</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="n">unbound_dims</span> <span class="o">=</span> <span class="n">batch_dims</span><span class="o">.</span><span class="n">unbind</span><span class="p">([</span><span class="s1">&#39;bd_1&#39;</span><span class="p">])</span>
<span class="n">squeezed_dims</span> <span class="o">=</span> <span class="n">batch_dims</span><span class="o">.</span><span class="n">squeeze_dims</span><span class="p">([</span><span class="s1">&#39;bd_2&#39;</span><span class="p">])</span>

<span class="c1"># Add DimTuples</span>
<span class="n">full_dims</span> <span class="o">=</span> <span class="n">batch_dims</span> <span class="o">+</span> <span class="n">event_dims</span>
<span class="c1"># raises an exception (as it should): batch_dims + bound_dims</span>

<span class="c1"># Multiply DimTuples</span>
<span class="c1"># Dimensions with size of 1 can be broadcasted over, names must match</span>
<span class="n">dt_factor_1</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;d1&#39;</span><span class="p">,</span> <span class="s1">&#39;d2&#39;</span><span class="p">,</span> <span class="s1">&#39;d3&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span>
<span class="n">dt_factor_2</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;d1&#39;</span><span class="p">,</span> <span class="s1">&#39;d2&#39;</span><span class="p">,</span> <span class="s1">&#39;d3&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">12</span><span class="p">])</span>
<span class="n">broadcasted_dims</span> <span class="o">=</span> <span class="n">dt_factor_1</span> <span class="o">*</span> <span class="n">dt_factor_2</span>        <span class="c1"># sizes = [5,3,None]</span>

<span class="c1"># Use torchdim functionality</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">torchdim_tuple</span> <span class="o">=</span> <span class="n">broadcasted_dims</span><span class="o">.</span><span class="n">build_torchdims</span><span class="p">()</span>
<span class="n">A_named</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">torchdim_tuple</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="tensor-classes-and-functions">
<h2>Tensor classes and functions<a class="headerlink" href="#tensor-classes-and-functions" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.tensor.CalipyIndex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.tensor.</span></span><span class="sig-name descname"><span class="pre">CalipyIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_tensor_dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.tensor.CalipyIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Class acting as a collection of infos on a specific index tensor collecting
basic index_tensor, index_tensor_tuple, and index_tensor_named. This class
represents a specific index tensor.</p>
<ul class="simple">
<li><p><cite>index_tensor.tensor</cite> is the original index tensor</p></li>
<li><p><cite>index_tensor.tuple</cite> can be used for indexing via <cite>data[tuple]</cite></p></li>
<li><p><cite>index_tensor.named</cite> can be used for dimension-specific operations</p></li>
</ul>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.tensor.CalipyIndexer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.tensor.</span></span><span class="sig-name descname"><span class="pre">CalipyIndexer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.tensor.CalipyIndexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class of an Indexer that implements methods for assigning dimensions
to specific slices of e.g. tensors or distributions. The methods and attributes
are rarely called directly; user interaction happens mostly with the subclasses
TensorIndexer and DistIndexer. Within these, functionality for subsampling,
batching, name generation etc are conretized. See those classes for examples
and specific implementation details.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.tensor.IOIndexer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.tensor.</span></span><span class="sig-name descname"><span class="pre">IOIndexer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">calipy_io</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.tensor.IOIndexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to handle indexing operations for CalipyIO objects, including creating
local and global indices, managing subsampling, and generating named dictionaries
for indexing purposes. Takes as input a CalipyIO object and a DimTuple object
and creates a CalipyIndexer object that can be used to produce indices, bind
dimensions, order the calipy_io and similar other support functionality.
Indexing is performed over the calipy_list elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>calipy_io</strong> (<a class="reference internal" href="#calipy.core.data.CalipyIO" title="calipy.core.data.CalipyIO"><em>CalipyIO</em></a>) – The CalipyIO object for which the indexer is to be constructed</p></li>
<li><p><strong>dims</strong> (<a class="reference internal" href="#calipy.core.utils.DimTuple" title="calipy.core.utils.DimTuple"><em>DimTuple</em></a>) – A DimTuple containing the dimensions of the tensor</p></li>
<li><p><strong>name</strong> (<em>string</em>) – A name for the indexer, useful for keeping track of subservient indexers.
Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of TensorIndexer containing functionality for indexing the
input tensor including subbatching, naming, index tensors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.tensor.TensorIndexer" title="calipy.core.tensor.TensorIndexer">TensorIndexer</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create DimTuples and tensors</span>
<span class="n">data_A_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">batch_dims_A</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bd_1_A&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_2_A&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.tensor.TensorIndexer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.tensor.</span></span><span class="sig-name descname"><span class="pre">TensorIndexer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.tensor.TensorIndexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to handle indexing operations for observations, including creating local
and global indices, managing subsampling, and generating named dictionaries
for indexing purposes. Takes as input a tensor and a DimTuple object and creates
a CalipyIndexer object that can be used to produce indices, bind dimensions, 
order the tensor and similar other support functionality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> (<em>torch.Tensor</em>) – The tensor for which the indexer is to be constructed</p></li>
<li><p><strong>dims</strong> (<a class="reference internal" href="#calipy.core.utils.DimTuple" title="calipy.core.utils.DimTuple"><em>DimTuple</em></a>) – A DimTuple containing the dimensions of the tensor</p></li>
<li><p><strong>name</strong> (<em>string</em>) – A name for the indexer, useful for keeping track of subservient indexers.
Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of TensorIndexer containing functionality for indexing the
input tensor including subbatching, naming, index tensors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.tensor.TensorIndexer" title="calipy.core.tensor.TensorIndexer">TensorIndexer</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create DimTuples and tensors</span>
<span class="n">data_A_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">batch_dims_A</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bd_1_A&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_2_A&#39;</span><span class="p">])</span>
<span class="n">event_dims_A</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_1_A&#39;</span><span class="p">])</span>
<span class="n">data_dims_A</span> <span class="o">=</span> <span class="n">batch_dims_A</span> <span class="o">+</span> <span class="n">event_dims_A</span>


<span class="c1"># Evoke indexer</span>
<span class="n">data_A</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_A_torch</span><span class="p">,</span> <span class="n">data_dims_A</span><span class="p">,</span> <span class="s1">&#39;data_A&#39;</span><span class="p">)</span>
<span class="n">indexer</span> <span class="o">=</span> <span class="n">data_A</span><span class="o">.</span><span class="n">indexer</span>
<span class="nb">print</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

<span class="c1"># Indexer contains the tensor, its dims, and bound tensor</span>
<span class="n">indexer</span><span class="o">.</span><span class="n">tensor</span>
<span class="n">indexer</span><span class="o">.</span><span class="n">tensor_dims</span>
<span class="n">indexer</span><span class="o">.</span><span class="n">tensor_dims</span><span class="o">.</span><span class="vm">__class__</span>
<span class="n">indexer</span><span class="o">.</span><span class="n">tensor_dims</span><span class="o">.</span><span class="n">sizes</span>
<span class="n">indexer</span><span class="o">.</span><span class="n">tensor_torchdims</span>
<span class="n">indexer</span><span class="o">.</span><span class="n">tensor_torchdims</span><span class="o">.</span><span class="vm">__class__</span>
<span class="n">indexer</span><span class="o">.</span><span class="n">tensor_torchdims</span><span class="o">.</span><span class="n">sizes</span>
<span class="n">indexer</span><span class="o">.</span><span class="n">tensor_named</span>
<span class="n">indexer</span><span class="o">.</span><span class="n">index_dim</span>
<span class="n">indexer</span><span class="o">.</span><span class="n">index_tensor_dims</span>

<span class="c1"># Functionality indexer</span>
<span class="n">attr_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">attr_list</span><span class="p">)</span>

<span class="c1"># Functionality index</span>
<span class="n">local_index</span> <span class="o">=</span> <span class="n">data_A</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>
<span class="n">local_index</span>
<span class="n">local_index</span><span class="o">.</span><span class="n">dims</span>
<span class="n">local_index</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span>
<span class="n">local_index</span><span class="o">.</span><span class="n">index_name_dict</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">data_A</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">local_index</span><span class="o">.</span><span class="n">tuple</span><span class="p">]</span> <span class="o">==</span> <span class="n">data_A</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="k">assert</span> <span class="p">((</span><span class="n">data_A</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_A</span><span class="p">)</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>


<span class="c1"># Reordering and indexing by DimTuple</span>
<span class="n">reordered_dims</span> <span class="o">=</span> <span class="n">DimTuple</span><span class="p">((</span><span class="n">data_dims_A</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data_dims_A</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">data_dims_A</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">data_A_reordered</span> <span class="o">=</span> <span class="n">data_A</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">reordered_dims</span><span class="p">)</span>
<span class="n">data_tdims_A</span> <span class="o">=</span> <span class="n">data_dims_A</span><span class="o">.</span><span class="n">build_torchdims</span><span class="p">()</span>
<span class="n">data_tdims_A_reordered</span> <span class="o">=</span> <span class="n">data_tdims_A</span><span class="p">[</span><span class="n">reordered_dims</span><span class="p">]</span>
<span class="n">data_A_named_tensor</span> <span class="o">=</span> <span class="n">data_A</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">data_tdims_A</span><span class="p">]</span>
<span class="n">data_A_named_tensor_reordered</span> <span class="o">=</span> <span class="n">data_A_reordered</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">data_tdims_A_reordered</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">data_A_named_tensor</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="o">*</span><span class="n">data_tdims_A</span><span class="p">)</span> <span class="o">==</span> <span class="n">data_A_named_tensor_reordered</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="o">*</span><span class="n">data_tdims_A</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># Subbatching along one or multiple dims</span>
<span class="n">subsamples</span><span class="p">,</span> <span class="n">subsample_indices</span> <span class="o">=</span> <span class="n">data_A</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">simple_subsample</span><span class="p">(</span><span class="n">batch_dims_A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shape subsamples = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="n">subsample</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">subsample</span> <span class="ow">in</span> <span class="n">subsamples</span><span class="p">]))</span>
<span class="n">block_batch_dims_A</span> <span class="o">=</span> <span class="n">batch_dims_A</span>
<span class="n">block_subsample_sizes_A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">block_subsamples</span><span class="p">,</span> <span class="n">block_subsample_indices</span> <span class="o">=</span> <span class="n">data_A</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">block_subsample</span><span class="p">(</span><span class="n">block_batch_dims_A</span><span class="p">,</span> <span class="n">block_subsample_sizes_A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shape block subsamples = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">([</span><span class="n">subsample</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">subsample</span> <span class="ow">in</span> <span class="n">block_subsamples</span><span class="p">]))</span>

<span class="c1"># Inheritance - by construction</span>
<span class="c1"># Suppose we got data_C as a subset of data_B with derived ssi CalipyIndex and</span>
<span class="c1"># now want to index data_C with proper names and references</span>
<span class="c1">#   1. generate data_B</span>
<span class="n">batch_dims_B</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd_1_B&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_2_B&#39;</span><span class="p">])</span>
<span class="n">event_dims_B</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;ed_1_B&#39;</span><span class="p">])</span>
<span class="n">data_dims_B</span> <span class="o">=</span> <span class="n">batch_dims_B</span> <span class="o">+</span> <span class="n">event_dims_B</span>
<span class="n">data_B_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">data_B</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_B_torch</span><span class="p">,</span> <span class="n">data_dims_B</span><span class="p">,</span> <span class="s1">&#39;data_B&#39;</span><span class="p">)</span>

<span class="c1">#   2. subsample data_C from data_B</span>
<span class="n">block_data_C</span><span class="p">,</span> <span class="n">block_indices_C</span> <span class="o">=</span> <span class="n">data_B</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">block_subsample</span><span class="p">(</span><span class="n">batch_dims_B</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">block_nr</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">data_C</span> <span class="o">=</span> <span class="n">block_data_C</span><span class="p">[</span><span class="n">block_nr</span><span class="p">]</span>
<span class="n">block_index_C</span> <span class="o">=</span> <span class="n">block_indices_C</span><span class="p">[</span><span class="n">block_nr</span><span class="p">]</span>

<span class="c1">#   3. subsampling has created an indexer for data_C</span>
<span class="n">data_C</span><span class="o">.</span><span class="n">indexer</span>
<span class="n">data_C</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>
<span class="n">data_C</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>
<span class="n">data_C</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span><span class="o">.</span><span class="n">tensor</span>
<span class="n">data_C</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="o">.</span><span class="n">tensor</span>
<span class="n">data_C</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="o">.</span><span class="n">index_name_dict</span>
<span class="n">data_C</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">data_source_name</span>

<span class="n">data_C_local_index</span> <span class="o">=</span> <span class="n">data_C</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>
<span class="n">data_C_global_index</span> <span class="o">=</span> <span class="n">data_C</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">data_C</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">data_C_local_index</span><span class="o">.</span><span class="n">tuple</span><span class="p">]</span> <span class="o">==</span> <span class="n">data_B</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">data_C_global_index</span><span class="o">.</span><span class="n">tuple</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="k">assert</span> <span class="p">((</span><span class="n">data_C</span><span class="p">[</span><span class="n">data_C_local_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_B</span><span class="p">[</span><span class="n">data_C_global_index</span><span class="p">])</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># Inheritance - by declaration</span>
<span class="c1"># If data comes out of some external subsampling and only the corresponding indextensors</span>
<span class="c1"># are known, the calipy_indexer can be evoked manually.</span>
<span class="n">data_D_torch</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data_C</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>
<span class="n">index_tensor_D</span> <span class="o">=</span> <span class="n">block_index_C</span><span class="o">.</span><span class="n">tensor</span>

<span class="n">data_D</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_D_torch</span><span class="p">,</span> <span class="n">data_dims_B</span><span class="p">,</span> <span class="s1">&#39;data_D&#39;</span><span class="p">)</span>
<span class="n">data_D</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">create_global_index</span><span class="p">(</span><span class="n">index_tensor_D</span><span class="p">,</span> <span class="s1">&#39;from_data_D&#39;</span><span class="p">)</span>
<span class="n">data_D_global_index</span> <span class="o">=</span> <span class="n">data_D</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>

<span class="k">assert</span> <span class="p">(</span><span class="n">data_D</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="n">data_B</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">data_D_global_index</span><span class="o">.</span><span class="n">tuple</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="k">assert</span> <span class="p">((</span><span class="n">data_D</span> <span class="o">-</span> <span class="n">data_B</span><span class="p">[</span><span class="n">data_D_global_index</span><span class="p">])</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># Alternative way of calling via DataTuples</span>
<span class="n">data_E_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">batch_dims_E</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bd_1_E&#39;</span><span class="p">])</span>
<span class="n">event_dims_E</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_1_E&#39;</span><span class="p">])</span>
<span class="n">data_dims_E</span> <span class="o">=</span> <span class="n">batch_dims_E</span> <span class="o">+</span> <span class="n">event_dims_E</span>

<span class="n">data_names_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data_A&#39;</span><span class="p">,</span> <span class="s1">&#39;data_E&#39;</span><span class="p">]</span>
<span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_A_torch</span><span class="p">,</span> <span class="n">data_E_torch</span><span class="p">]</span>
<span class="n">data_datatuple_torch</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">(</span><span class="n">data_names_list</span><span class="p">,</span> <span class="n">data_list</span><span class="p">)</span>

<span class="n">batch_dims_datatuple</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">(</span><span class="n">data_names_list</span><span class="p">,</span> <span class="p">[</span><span class="n">batch_dims_A</span><span class="p">,</span> <span class="n">batch_dims_E</span><span class="p">])</span>
<span class="n">event_dims_datatuple</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">(</span><span class="n">data_names_list</span><span class="p">,</span> <span class="p">[</span><span class="n">event_dims_A</span><span class="p">,</span> <span class="n">event_dims_E</span><span class="p">])</span>
<span class="n">data_dims_datatuple</span> <span class="o">=</span> <span class="n">batch_dims_datatuple</span> <span class="o">+</span> <span class="n">event_dims_datatuple</span>

<span class="n">data_datatuple</span> <span class="o">=</span> <span class="n">data_datatuple_torch</span><span class="o">.</span><span class="n">calipytensor_construct</span><span class="p">(</span><span class="n">data_dims_datatuple</span><span class="p">)</span>
<span class="n">data_datatuple</span><span class="p">[</span><span class="s1">&#39;data_A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">indexer</span>


<span class="c1"># Functionality for creating indices with TensorIndexer class methods</span>
<span class="c1"># It is possible to create subsample_indices even when no tensor is given</span>
<span class="c1"># simply by calling the class method TensorIndexer.create_block_subsample_indices</span>
<span class="c1"># or TensorIndexer.create_simple_subsample_indices and providing the </span>
<span class="c1"># appropriate size specifications.         </span>
<span class="c1"># i) Create the dims (with unspecified size so no conflict later when subbatching)</span>
<span class="n">batch_dims_FG</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd_1_FG&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_2_FG&#39;</span><span class="p">])</span>
<span class="n">event_dims_F</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;ed_1_F&#39;</span><span class="p">,</span> <span class="s1">&#39;ed_2_F&#39;</span><span class="p">])</span>
<span class="n">event_dims_G</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;ed_1_G&#39;</span><span class="p">])</span>
<span class="n">data_dims_F</span> <span class="o">=</span> <span class="n">batch_dims_FG</span> <span class="o">+</span> <span class="n">event_dims_F</span>
<span class="n">data_dims_G</span> <span class="o">=</span> <span class="n">batch_dims_FG</span> <span class="o">+</span> <span class="n">event_dims_G</span>

<span class="c1"># ii) Sizes</span>
<span class="n">batch_dims_FG_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="n">event_dims_F_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">event_dims_G_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="n">data_dims_F_sizes</span> <span class="o">=</span> <span class="n">batch_dims_FG_sizes</span> <span class="o">+</span> <span class="n">event_dims_F_sizes</span>
<span class="n">data_dims_G_sizes</span> <span class="o">=</span> <span class="n">batch_dims_FG_sizes</span> <span class="o">+</span> <span class="n">event_dims_G_sizes</span>

<span class="c1"># iii) Then create the data</span>
<span class="n">data_F_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_dims_F_sizes</span><span class="p">)</span>
<span class="n">data_F</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_F_torch</span><span class="p">,</span> <span class="n">data_dims_F</span><span class="p">,</span> <span class="s1">&#39;data_F&#39;</span><span class="p">)</span>
<span class="n">data_G_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_dims_G_sizes</span><span class="p">)</span>
<span class="n">data_G</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_G_torch</span><span class="p">,</span> <span class="n">data_dims_G</span><span class="p">,</span> <span class="s1">&#39;data_G&#39;</span><span class="p">)</span>

<span class="c1"># iv) Create and expand the reduced_index</span>
<span class="n">indices_reduced</span> <span class="o">=</span> <span class="n">TensorIndexer</span><span class="o">.</span><span class="n">create_block_subsample_indices</span><span class="p">(</span><span class="n">batch_dims_FG</span><span class="p">,</span> <span class="n">batch_dims_FG_sizes</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="n">index_reduced</span> <span class="o">=</span> <span class="n">indices_reduced</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Functionality for expanding, reducing, and reordering indices</span>
<span class="c1"># Indices like the ones above can be used flexibly by expanding them to</span>
<span class="c1"># fit tensors with various dimensions. They can also be changed w.r.t </span>
<span class="c1"># their order.</span>

<span class="c1"># i) Expand index to fit data_F and data_G</span>
<span class="n">index_expanded_F</span> <span class="o">=</span> <span class="n">index_reduced</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">data_dims_F</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_dims_FG</span><span class="p">)</span> <span class="o">+</span> <span class="n">event_dims_F_sizes</span><span class="p">)</span>
<span class="n">index_expanded_G</span> <span class="o">=</span> <span class="n">index_reduced</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">data_dims_G</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_dims_FG</span><span class="p">)</span> <span class="o">+</span> <span class="n">event_dims_G_sizes</span><span class="p">)</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">data_F</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">index_expanded_F</span><span class="o">.</span><span class="n">tuple</span><span class="p">]</span> <span class="o">==</span> <span class="n">data_F</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">index_reduced</span><span class="o">.</span><span class="n">tensor</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">index_reduced</span><span class="o">.</span><span class="n">tensor</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,:])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="k">assert</span> <span class="p">((</span><span class="n">data_F</span><span class="p">[</span><span class="n">index_expanded_F</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_F</span><span class="p">[</span><span class="n">index_reduced</span><span class="o">.</span><span class="n">tensor</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">index_reduced</span><span class="o">.</span><span class="n">tensor</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,:])</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># ii) Reordering is done by passing in a differently ordered DimTuple</span>
<span class="n">data_dims_F_reordered</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;ed_2_F&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_2_FG&#39;</span><span class="p">,</span> <span class="s1">&#39;ed_1_F&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_1_FG&#39;</span><span class="p">])</span>
<span class="n">data_dims_F_reordered_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
<span class="n">index_expanded_F_reordered</span> <span class="o">=</span> <span class="n">index_reduced</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">data_dims_F_reordered</span><span class="p">,</span> <span class="n">data_dims_F_reordered_sizes</span><span class="p">)</span>
<span class="n">data_F_reordered</span> <span class="o">=</span> <span class="n">data_F</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">data_dims_F_reordered</span><span class="p">)</span>
<span class="n">data_F_subsample</span> <span class="o">=</span> <span class="n">data_F</span><span class="p">[</span><span class="n">index_expanded_F</span><span class="p">]</span>
<span class="n">data_F_reordered_subsample</span> <span class="o">=</span> <span class="n">data_F_reordered</span><span class="p">[</span><span class="n">index_expanded_F_reordered</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">data_F_subsample</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="n">data_F_reordered_subsample</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">permute</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># iii) Index expansion can also be performed by the indexer of a tensor;</span>
<span class="c1"># this is usually more convenient</span>
<span class="n">index_expanded_F_alt</span> <span class="o">=</span> <span class="n">data_F</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">expand_index</span><span class="p">(</span><span class="n">index_reduced</span><span class="p">)</span>
<span class="n">index_expanded_G_alt</span> <span class="o">=</span> <span class="n">data_G</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">expand_index</span><span class="p">(</span><span class="n">index_reduced</span><span class="p">)</span>
<span class="n">data_F_subsample_alt</span> <span class="o">=</span> <span class="n">data_F</span><span class="p">[</span><span class="n">index_expanded_F_alt</span><span class="o">.</span><span class="n">tuple</span><span class="p">]</span>
<span class="n">data_G_subsample_alt</span> <span class="o">=</span> <span class="n">data_G</span><span class="p">[</span><span class="n">index_expanded_G_alt</span><span class="o">.</span><span class="n">tuple</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">data_F_subsample</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="n">data_F_subsample_alt</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="k">assert</span> <span class="p">((</span><span class="n">data_F_subsample</span> <span class="o">-</span> <span class="n">data_F_subsample_alt</span><span class="p">)</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># Inverse operation is index_reduction (only possible when index is cartesian product)</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">index_expanded_F</span><span class="o">.</span><span class="n">is_reducible</span><span class="p">(</span><span class="n">batch_dims_FG</span><span class="p">))</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">index_reduced</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="n">index_expanded_F</span><span class="o">.</span><span class="n">reduce_to_dims</span><span class="p">(</span><span class="n">batch_dims_FG</span><span class="p">)</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">index_reduced</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="n">index_expanded_G</span><span class="o">.</span><span class="n">reduce_to_dims</span><span class="p">(</span><span class="n">batch_dims_FG</span><span class="p">)</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c1"># Illustrate nonseparable case</span>
<span class="n">inseparable_index</span> <span class="o">=</span> <span class="n">CalipyIndex</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="n">data_dims_F</span><span class="p">)</span>
<span class="n">inseparable_index</span><span class="o">.</span><span class="n">is_reducible</span><span class="p">(</span><span class="n">batch_dims_FG</span><span class="p">)</span>
<span class="n">inseparable_index</span><span class="o">.</span><span class="n">reduce_to_dims</span><span class="p">(</span><span class="n">batch_dims_FG</span><span class="p">)</span> <span class="c1"># Produces a warning as it should</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.tensor.CalipyTensor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.tensor.</span></span><span class="sig-name descname"><span class="pre">CalipyTensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tensor_noname'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.tensor.CalipyTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that wraps torch.Tensor objects and augments them with indexing operations
and dimension upkeep functionality, while referring most torch functions to
its wrapped torch. Tensor object. Can be sliced and indexed in the usual ways
which produces another CalipyTensor whose indexer is inherited.</p>
<dl class="simple">
<dt>Special creation rules for calipy tensors:</dt><dd><ol class="lowerroman simple">
<li><p>If tensor is None, dims must be None. Produces null object</p></li>
<li><p>If tensor exists and dims are None. Produces calipy tensor with generic dims</p></li>
<li><p>If calipy tensor is passed as input. Produces the same calipy tensor</p></li>
<li><p>If calipy tensor is passed as input and some dims. Produces new calipy
tensor with new dims.</p></li>
<li><p>It tensor exists and dims exist, produce regular calipy tensor.</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> (<em>torch.Tensor</em>) – The tensor which should be embedded into CalipyTensor</p></li>
<li><p><strong>dims</strong> (<a class="reference internal" href="#calipy.core.utils.DimTuple" title="calipy.core.utils.DimTuple"><em>DimTuple</em></a>) – A DimTuple containing the dimensions of the tensor or None</p></li>
<li><p><strong>name</strong> (<em>string</em>) – A name for the CalipyTensor, useful for keeping track of derived CalipyTensor’s.
Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of CalipyTensor containing functionality for dimension
upkeep, indexing, and function call referral.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.tensor.CalipyTensor" title="calipy.core.tensor.CalipyTensor">CalipyTensor</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Imports and definitions</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">calipy.core.tensor</span> <span class="kn">import</span> <span class="n">CalipyTensor</span><span class="p">,</span> <span class="n">TensorIndexer</span><span class="p">,</span> <span class="n">CalipyIndex</span>
<span class="kn">from</span> <span class="nn">calipy.core.utils</span> <span class="kn">import</span> <span class="n">dim_assignment</span>
<span class="kn">from</span> <span class="nn">calipy.core.data</span> <span class="kn">import</span> <span class="n">DataTuple</span>

<span class="c1"># Create CalipyTensors -----------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># Create DimTuples and tensors</span>
<span class="n">data_A_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">batch_dims_A</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bd_1_A&#39;</span><span class="p">,</span> <span class="s1">&#39;bd_2_A&#39;</span><span class="p">])</span>
<span class="n">event_dims_A</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_1_A&#39;</span><span class="p">])</span>
<span class="n">data_dims_A</span> <span class="o">=</span> <span class="n">batch_dims_A</span> <span class="o">+</span> <span class="n">event_dims_A</span>
<span class="n">data_A_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_A_torch</span><span class="p">,</span> <span class="n">data_dims_A</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;data_A&#39;</span><span class="p">)</span>

<span class="c1"># Confirm that subsampling works as intended</span>
<span class="n">subtensor_1</span> <span class="o">=</span> <span class="n">data_A_cp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>  <span class="c1"># identical to next line</span>
<span class="n">subtensor_1</span> <span class="o">=</span> <span class="n">data_A_cp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
<span class="n">subtensor_1</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">dims</span>
<span class="k">assert</span><span class="p">((</span><span class="n">subtensor_1</span><span class="o">.</span><span class="n">tensor</span> <span class="o">-</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="c1"># subsample has global_index that can be used for subsampling on tensors</span>
<span class="c1"># and on CalipyTensors</span>
<span class="k">assert</span><span class="p">((</span><span class="n">data_A_cp</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">subtensor_1</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="o">.</span><span class="n">tuple</span><span class="p">]</span> 
        <span class="o">-</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="k">assert</span><span class="p">(((</span><span class="n">data_A_cp</span><span class="p">[</span><span class="n">subtensor_1</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="p">]</span> 
        <span class="o">-</span> <span class="n">data_A_cp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">...</span><span class="p">])</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

<span class="c1"># When using an integer, dims are kept; i.e. singleton dims are not reduced</span>
<span class="n">subtensor_2</span> <span class="o">=</span> <span class="n">data_A_cp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
<span class="k">assert</span><span class="p">((</span><span class="n">subtensor_2</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="n">data_A_cp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

<span class="c1"># Indexing of CalipyTensors via int, tuple, slice, and CalipyIndex</span>
<span class="n">data_A_cp</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
<span class="n">local_index</span> <span class="o">=</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>
<span class="n">data_A_cp</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span>
<span class="c1"># During addressing, appropriate indexers are built</span>
<span class="n">data_A_cp</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>
<span class="n">data_A_cp</span><span class="p">[</span><span class="n">local_index</span><span class="p">]</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>

<span class="c1"># CalipyTensors work well even when some dims are empty</span>
<span class="c1"># Set up data and dimensions</span>
<span class="n">data_0dim</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">([])</span>
<span class="n">data_1dim</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span>
<span class="n">data_2dim</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

<span class="n">batch_dim</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd&#39;</span><span class="p">])</span>
<span class="n">event_dim</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;ed&#39;</span><span class="p">])</span>
<span class="n">empty_dim</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;empty&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[])</span>

<span class="n">data_0dim_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_0dim</span><span class="p">,</span> <span class="n">empty_dim</span><span class="p">)</span>
<span class="n">data_1dim_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_1dim</span><span class="p">,</span> <span class="n">batch_dim</span><span class="p">)</span>
<span class="n">data_1dim_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_1dim</span><span class="p">,</span> <span class="n">batch_dim</span> <span class="o">+</span> <span class="n">empty_dim</span><span class="p">)</span>
<span class="n">data_1dim_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_1dim</span><span class="p">,</span> <span class="n">empty_dim</span> <span class="o">+</span> <span class="n">batch_dim</span> <span class="o">+</span> <span class="n">empty_dim</span><span class="p">)</span>

<span class="n">data_2dim_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_2dim</span><span class="p">,</span> <span class="n">batch_dim</span> <span class="o">+</span> <span class="n">event_dim</span><span class="p">)</span>
<span class="n">data_2dim_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_2dim</span><span class="p">,</span> <span class="n">batch_dim</span> <span class="o">+</span> <span class="n">empty_dim</span> <span class="o">+</span> <span class="n">event_dim</span><span class="p">)</span>

<span class="c1"># Indexing a scalar with an empty index just returns the scalar</span>
<span class="n">data_0dim_cp</span><span class="o">.</span><span class="n">indexer</span>
<span class="n">zerodim_index</span> <span class="o">=</span> <span class="n">data_0dim_cp</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>
<span class="n">zerodim_index</span><span class="o">.</span><span class="n">is_empty</span>
<span class="n">data_0dim_cp</span><span class="p">[</span><span class="n">zerodim_index</span><span class="p">]</span>

<span class="c1"># # These produce errors or warnings as they should.</span>
<span class="c1"># data_0dim_cp = CalipyTensor(data_0dim, batch_dim) # Trying to assign nonempty dim to scalar</span>
<span class="c1"># data_1dim_cp = CalipyTensor(data_1dim, empty_dim) # Trying to assign empty dim to vector</span>
<span class="c1"># data_2dim_cp = CalipyTensor(data_2dim, batch_dim + empty_dim) # Trying to assign empty dim to vector</span>


<span class="c1"># CalipyTensor / DataTuple interaction ---------------------------------</span>
<span class="c1">#</span>
<span class="c1"># DataTuple and CalipyTensor interact well: In the following we showcase</span>
<span class="c1"># that a DataTuple of CalipyTensors can be subsampled by providing a</span>
<span class="c1"># DataTuple of CalipyIndexes or a single CalipyIndex that is automatically</span>
<span class="c1"># distributed over the CalipyTensors for indexing.</span>

<span class="c1"># Set up DataTuple of CalipyTensors</span>
<span class="n">batch_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bd_1&#39;</span><span class="p">])</span>
<span class="n">event_dims_A</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_1_A&#39;</span><span class="p">,</span> <span class="s1">&#39;ed_2_A&#39;</span><span class="p">])</span>
<span class="n">data_dims_A</span> <span class="o">=</span> <span class="n">batch_dims</span> <span class="o">+</span> <span class="n">event_dims_A</span>
<span class="n">event_dims_B</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_1_B&#39;</span><span class="p">])</span>
<span class="n">data_dims_B</span> <span class="o">=</span> <span class="n">batch_dims</span> <span class="o">+</span> <span class="n">event_dims_B</span>
<span class="n">data_A_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">data_A_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_A_torch</span><span class="p">,</span> <span class="n">data_dims_A</span><span class="p">,</span> <span class="s1">&#39;data_A&#39;</span><span class="p">)</span>
<span class="n">data_B_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">data_B_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_B_torch</span><span class="p">,</span> <span class="n">data_dims_B</span><span class="p">,</span> <span class="s1">&#39;data_B&#39;</span><span class="p">)</span>

<span class="n">data_AB_tuple</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">([</span><span class="s1">&#39;data_A_cp&#39;</span><span class="p">,</span> <span class="s1">&#39;data_B_cp&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">data_A_cp</span><span class="p">,</span> <span class="n">data_B_cp</span><span class="p">])</span>


<span class="c1"># Subsampling functionality -------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># subsample the data individually</span>
<span class="n">data_AB_subindices</span> <span class="o">=</span> <span class="n">TensorIndexer</span><span class="o">.</span><span class="n">create_simple_subsample_indices</span><span class="p">(</span><span class="n">batch_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">data_AB_subindex</span> <span class="o">=</span> <span class="n">data_AB_subindices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">data_A_subindex</span> <span class="o">=</span> <span class="n">data_AB_subindex</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">data_dims_A</span><span class="p">,</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">data_B_subindex</span> <span class="o">=</span> <span class="n">data_AB_subindex</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">data_dims_B</span><span class="p">,</span> <span class="n">data_B_cp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">data_AB_sub_1</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">([</span><span class="s1">&#39;data_A_cp_sub&#39;</span><span class="p">,</span> <span class="s1">&#39;data_B_cp_sub&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">data_A_cp</span><span class="p">[</span><span class="n">data_A_subindex</span><span class="p">],</span> <span class="n">data_B_cp</span><span class="p">[</span><span class="n">data_B_subindex</span><span class="p">]])</span>

<span class="c1"># Use subsampling functionality for DataTuples, either by passing a DataTuple of</span>
<span class="c1"># CalipyIndex or a single CalipyIndex that is broadcasted</span>
<span class="n">data_AB_subindex_tuple</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">([</span><span class="s1">&#39;data_A_cp&#39;</span><span class="p">,</span> <span class="s1">&#39;data_B_cp&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">data_A_subindex</span><span class="p">,</span> <span class="n">data_B_subindex</span><span class="p">])</span>
<span class="n">data_AB_sub_2</span> <span class="o">=</span> <span class="n">data_AB_tuple</span><span class="o">.</span><span class="n">subsample</span><span class="p">(</span><span class="n">data_AB_subindex_tuple</span><span class="p">)</span>
<span class="n">data_AB_sub_3</span> <span class="o">=</span> <span class="n">data_AB_tuple</span><span class="o">.</span><span class="n">subsample</span><span class="p">(</span><span class="n">data_AB_subindex</span><span class="p">)</span>
<span class="k">assert</span> <span class="p">((</span><span class="n">data_AB_sub_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_AB_sub_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="k">assert</span> <span class="p">((</span><span class="n">data_AB_sub_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_AB_sub_3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>


<span class="c1"># Expansion and reordering -------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># Expand a tensor by copying it among some dimensions.</span>
<span class="n">data_dims_A</span> <span class="o">=</span> <span class="n">data_dims_A</span><span class="o">.</span><span class="n">bind</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">data_dims_B</span> <span class="o">=</span> <span class="n">data_dims_B</span><span class="o">.</span><span class="n">bind</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">data_dims_expanded</span> <span class="o">=</span> <span class="n">data_dims_A</span> <span class="o">+</span> <span class="n">data_dims_B</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">data_A_expanded_cp</span> <span class="o">=</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">data_dims_expanded</span><span class="p">)</span>
<span class="k">assert</span><span class="p">((</span><span class="n">data_A_expanded_cp</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">-</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="c1"># Ordering of dims is also ordering of result</span>
<span class="n">data_dims_expanded_reordered</span> <span class="o">=</span> <span class="n">data_dims_A</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">data_dims_A</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">data_dims_B</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">data_A_expanded_reordered_cp</span> <span class="o">=</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">data_dims_expanded_reordered</span><span class="p">)</span>
<span class="k">assert</span><span class="p">((</span><span class="n">data_A_expanded_reordered_cp</span><span class="o">.</span><span class="n">tensor</span> <span class="o">-</span>
        <span class="n">data_A_expanded_cp</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>

<span class="c1"># There also exists a CalipyTensor.reorder(dims) method</span>
<span class="n">data_dims_A_reordered</span> <span class="o">=</span> <span class="n">event_dims_A</span> <span class="o">+</span> <span class="n">batch_dims</span>
<span class="n">data_A_reordered_cp</span> <span class="o">=</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">data_dims_A_reordered</span><span class="p">)</span>
<span class="k">assert</span><span class="p">((</span><span class="n">data_A_reordered_cp</span><span class="o">.</span><span class="n">tensor</span> <span class="o">-</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
<span class="k">assert</span><span class="p">(</span><span class="n">data_A_reordered_cp</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="n">data_dims_A_reordered</span><span class="p">)</span>


<span class="c1"># Null object functionality -------------------------------------------</span>

<span class="c1"># CalipyTensors and CalipyIndex also work with None inputs to produce Null objects</span>
<span class="c1"># Create data for initialization</span>
<span class="n">tensor_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd&#39;</span><span class="p">,</span> <span class="s1">&#39;ed&#39;</span><span class="p">])</span>
<span class="n">tensor_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">tensor_dims</span><span class="p">)</span> 
<span class="n">tensor_none</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">index_full</span> <span class="o">=</span> <span class="n">tensor_cp</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>
<span class="n">index_none</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># ii) Create and investigate null CalipyIndex</span>
<span class="n">CI_none</span> <span class="o">=</span> <span class="n">CalipyIndex</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">CI_none</span><span class="p">)</span>
<span class="n">CI_expanded</span> <span class="o">=</span> <span class="n">CI_none</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">tensor_dims</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

<span class="c1"># Passing a null index to CalipyTensor returns the orginal tensor.</span>
<span class="n">tensor_cp</span><span class="p">[</span><span class="n">CI_none</span><span class="p">]</span>
<span class="n">tensor_cp</span><span class="p">[</span><span class="n">CI_expanded</span><span class="p">]</span>
<span class="c1"># The following errors out, as intended: </span>
<span class="c1">#   CalipyIndex(torch.ones([1]), index_tensor_dims = None)</span>

<span class="c1"># iii) Create and investigate null CalipyTensor</span>
<span class="n">CT_none</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="n">CT_none</span>
<span class="n">CT_none</span><span class="p">[</span><span class="n">CI_none</span><span class="p">]</span> 
<span class="n">CT_none</span><span class="p">[</span><span class="n">CI_expanded</span><span class="p">]</span>

<span class="n">tensor_dims_bound</span> <span class="o">=</span> <span class="n">tensor_dims</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">tensor_cp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">CT_expanded</span> <span class="o">=</span> <span class="n">CT_none</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">tensor_dims_bound</span><span class="p">)</span>
<span class="c1"># The following errors out, as intended: </span>
<span class="c1">#   CalipyIndex(torch.ones([1]), index_tensor_dims = None)</span>


<span class="c1"># Special creation rules for calipy tensors ---------------------------</span>
<span class="c1">#   i) If tensor is None, dims must be None. Produces null object</span>
<span class="c1">#   ii) If tensor exists and dims are None. Produces calipy tensor with generic dims</span>
<span class="c1">#   iii) If calipy tensor is passed as input. Produces the same calipy tensor</span>
<span class="c1">#   iv) If calipy tensor is passd as input and some dims. Produces new calipy tensor with new dims.</span>

<span class="n">tensor_A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">dims_A</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd&#39;</span><span class="p">,</span> <span class="s1">&#39;ed&#39;</span><span class="p">])</span>
<span class="n">dims_A_alt</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd_alt&#39;</span><span class="p">,</span> <span class="s1">&#39;ed_alt&#39;</span><span class="p">])</span>
<span class="n">tensor_A_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">tensor_A</span><span class="p">,</span> <span class="n">dims_A</span><span class="p">)</span>

<span class="n">tensor_cp_None</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="n">tensor_cp_default</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">tensor_A</span><span class="p">)</span>
<span class="n">tensor_cp_idempotent</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">tensor_A_cp</span><span class="p">)</span>
<span class="n">tensor_cp_alt</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">tensor_A_cp</span><span class="p">,</span> <span class="n">dims_A_alt</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tensor_cp_alt</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.tensor.preprocess_args">
<span class="sig-prename descclassname"><span class="pre">calipy.core.tensor.</span></span><span class="sig-name descname"><span class="pre">preprocess_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.tensor.preprocess_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively preprocesses and unwraps input arguments and keyword arguments
by replacing any nested CalipyTensor objects with their underlying torch.Tensor 
instances. Supports arbitrary nesting including dictionaries, lists, tuples, and sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> (<em>tuple</em>) – Positional arguments potentially containing nested CalipyTensor
instances.</p></li>
<li><p><strong>kwargs</strong> (<em>dict</em>) – Keyword arguments potentially containing nested CalipyTensor
instances.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple consisting of unwrapped positional arguments and keyword arguments
with all CalipyTensor instances replaced by torch.Tensor objects.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(tuple, dict)</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Imports and definitions</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">calipy.core.tensor</span> <span class="kn">import</span> <span class="n">CalipyTensor</span><span class="p">,</span> <span class="n">preprocess_args</span>

<span class="c1"># Create sample CalipyTensors</span>
<span class="n">batch_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bd_1&#39;</span><span class="p">])</span>
<span class="n">event_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_1&#39;</span><span class="p">])</span>
<span class="n">data_dims</span> <span class="o">=</span> <span class="n">batch_dims</span> <span class="o">+</span> <span class="n">event_dims</span>
<span class="n">tensor_a</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">data_dims</span><span class="p">)</span>
<span class="n">tensor_b</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]),</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">data_dims</span><span class="p">)</span>

<span class="c1"># Nested structure containing CalipyTensors</span>
<span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">tensor_a</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;key1&#39;</span><span class="p">:</span> <span class="n">tensor_b</span><span class="p">,</span> <span class="s1">&#39;key2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">tensor_a</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;param&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;nested&#39;</span><span class="p">:</span> <span class="n">tensor_b</span><span class="p">}}</span>

<span class="n">unwrapped_args</span><span class="p">,</span> <span class="n">unwrapped_kwargs</span> <span class="o">=</span> <span class="n">preprocess_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unwrapped_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unwrapped_args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;key1&#39;</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unwrapped_kwargs</span><span class="p">[</span><span class="s1">&#39;param&#39;</span><span class="p">][</span><span class="s1">&#39;nested&#39;</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.tensor.build_dim_supersequence">
<span class="sig-prename descclassname"><span class="pre">calipy.core.tensor.</span></span><span class="sig-name descname"><span class="pre">build_dim_supersequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seq2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.tensor.build_dim_supersequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a minimal supersequence of dimension names that contains seq1 and seq2
as subsequences in the same relative order. Names that appear in both sequences
are placed (and unified) only once, if they appear in a non-contradictory order.</p>
<p>If no valid ordering is possible (e.g., seq1 = [dim1, dim2] and seq2 = [dim2, dim1]),
this raises a ValueError.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seq1</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The first dimension name sequence (list of strings).</p></li>
<li><p><strong>seq2</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The second dimension name sequence (list of strings).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A minimal supersequence (list of strings) that includes seq1 and seq2
in order, unifying repeated names.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[str]</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Good case:</span>
<span class="n">seq1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dim1&#39;</span><span class="p">,</span><span class="s1">&#39;dim2&#39;</span><span class="p">]</span>
<span class="n">seq2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dim2&#39;</span><span class="p">,</span><span class="s1">&#39;dim3&#39;</span><span class="p">]</span>
<span class="n">supersequence</span> <span class="o">=</span> <span class="n">build_dim_supersequence</span><span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">)</span>
<span class="c1"># =&gt; supersequence = [&#39;dim1&#39;,&#39;dim2&#39;,&#39;dim3&#39;,&#39;dim4&#39;]</span>

<span class="c1"># More complicated case</span>
<span class="n">seq1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dim1&#39;</span><span class="p">,</span> <span class="s1">&#39;dim2&#39;</span><span class="p">,</span> <span class="s1">&#39;dim4&#39;</span><span class="p">]</span>
<span class="n">seq2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dim2&#39;</span><span class="p">,</span>  <span class="s1">&#39;dim3&#39;</span><span class="p">,</span> <span class="s1">&#39;dim4&#39;</span><span class="p">]</span>
<span class="n">supersequence</span> <span class="o">=</span> <span class="n">build_dim_supersequence</span><span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">)</span>
<span class="c1"># =&gt; supersequence  = [&#39;dim1&#39;, &#39;dim2&#39;, &#39;dim3&#39;, &#39;dim4&#39;]</span>

<span class="c1"># Even more complicated case:</span>
<span class="n">seq1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dim1&#39;</span><span class="p">,</span> <span class="s1">&#39;dim2&#39;</span><span class="p">,</span> <span class="s1">&#39;dim4&#39;</span><span class="p">,</span> <span class="s1">&#39;dim5&#39;</span><span class="p">]</span>
<span class="n">seq2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dim2&#39;</span><span class="p">,</span>  <span class="s1">&#39;dim3&#39;</span><span class="p">,</span> <span class="s1">&#39;dim4&#39;</span><span class="p">,</span> <span class="s1">&#39;dim6&#39;</span><span class="p">]</span>
<span class="n">supersequence</span> <span class="o">=</span> <span class="n">build_dim_supersequence</span><span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">)</span>
<span class="c1"># =&gt; supersequence  = [&#39;dim1&#39;, &#39;dim2&#39;, &#39;dim3&#39;, &#39;dim4&#39;, &#39;dim5&#39;, &#39;dim6&#39;]  </span>

<span class="c1"># Contradiction:</span>
<span class="n">seq1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dim1&#39;</span><span class="p">,</span><span class="s1">&#39;dim2&#39;</span><span class="p">]</span>
<span class="n">seq2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dim2&#39;</span><span class="p">,</span><span class="s1">&#39;dim1&#39;</span><span class="p">]</span>
<span class="n">supersequence</span> <span class="o">=</span> <span class="n">build_dim_supersequence</span><span class="p">(</span><span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">)</span>
<span class="c1"># =&gt; raises ValueError</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.tensor._is_subsequence">
<span class="sig-prename descclassname"><span class="pre">calipy.core.tensor.</span></span><span class="sig-name descname"><span class="pre">_is_subsequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">small</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">big</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.tensor._is_subsequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the list ‘small’ is a subsequence (in order) of ‘big’.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.tensor.broadcast_dims">
<span class="sig-prename descclassname"><span class="pre">calipy.core.tensor.</span></span><span class="sig-name descname"><span class="pre">broadcast_dims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.tensor.broadcast_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if DimTuples <code class="docutils literal notranslate"><span class="pre">dims_1</span></code> and <code class="docutils literal notranslate"><span class="pre">dims_2</span></code> can be broadcasted together and,
if so, produces a new DimTuple that employs PyTorch’s broadcasting logic on
extended dims. Unlike a simple right-to-left alignment, this version explicitly
pads DimTuples towards a consistent superDimTuple with dims of size=1 where
dims need to be injected for consistency. Then pytorchs broadcasting functionality
is called on the extended shapes.</p>
<p>This helps avoid the scenario where the last dimension of one tensor is
matched with the first dimension of another just because of naive negative
indexing. We thereby do not fully emulate how PyTorch handles missing dims
but achieve a more dimension aware broadcast.</p>
<dl class="simple">
<dt>Steps:</dt><dd><ol class="arabic simple">
<li><p>Merge dimension name sequences into a minimal supersequence.</p></li>
<li><p>Expand each DimTuple to that full name list, filling size=1
for missing dims.</p></li>
<li><p>Let PyTorch do shape-based broadcasting.</p></li>
<li><p>Build a final DimTuple from the broadcasted shape, reusing
dimension names from the supersequence.</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims_1</strong> (<a class="reference internal" href="#calipy.core.utils.DimTuple" title="calipy.core.utils.DimTuple"><em>DimTuple</em></a><em> or </em><em>None</em>) – The first DimTuple to broadcast, or None/empty to indicate no dims.</p></li>
<li><p><strong>dims_2</strong> (<a class="reference internal" href="#calipy.core.utils.DimTuple" title="calipy.core.utils.DimTuple"><em>DimTuple</em></a><em> or </em><em>None</em>) – The second DimTuple to broadcast, or None/empty to indicate no dims.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DimTuple reflecting the broadcasted shape if compatible, otherwise None.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.utils.DimTuple" title="calipy.core.utils.DimTuple">DimTuple</a> or None</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">calipy.core.tensor</span> <span class="kn">import</span> <span class="n">CalipyTensor</span><span class="p">,</span> <span class="n">broadcast_dims</span>
<span class="kn">from</span> <span class="nn">calipy.core.utils</span> <span class="kn">import</span> <span class="n">Dim</span><span class="p">,</span> <span class="n">DimTuple</span><span class="p">,</span> <span class="n">dim_assignment</span>

<span class="c1"># Suppose we have:</span>
<span class="c1">#   c_cp of shape [2, 1], dims=(&#39;dim1&#39;,&#39;dim2&#39;)</span>
<span class="c1">#   b_cp of shape [2],    dims=(&#39;dim1&#39;,)</span>
<span class="c1"># This function ensures the second tensor is padded to [1,2],</span>
<span class="c1"># then does standard broadcasting, leading to final shape [2,2].</span>
<span class="c1"># We unify dimension names accordingly.</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="primitive-classes-and-functions">
<h2>Primitive classes and functions<a class="headerlink" href="#primitive-classes-and-functions" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.primitives.param">
<span class="sig-prename descclassname"><span class="pre">calipy.core.primitives.</span></span><span class="sig-name descname"><span class="pre">param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Real()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subsample_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.primitives.param" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper function for pyro.param producing a CalipyTensor valued parameter.
The tensor is inialized once, then placed in the param store and can be used
like a regular CalipyTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>string</em>) – Unique name of the parameter</p></li>
<li><p><strong>init_tensor</strong> (<em>torch.tensor</em>) – The initial value of the parameter tensor, adjusted later
on by optimization</p></li>
<li><p><strong>dims</strong> (<a class="reference internal" href="#calipy.core.utils.DimTuple" title="calipy.core.utils.DimTuple"><em>DimTuple</em></a>) – A tuple of dimensions indicating the dims of the CalipyTensor
created by param()</p></li>
<li><p><strong>constraint</strong> (<em>pyro.distributions.constraints.Constraint</em>) – Pyro constraint that constrains the parameter of a distribution
to lie in a pre-defined subspace of R^n like e.g. simplex, positive, …</p></li>
<li><p><strong>subsample_index</strong> (<a class="reference internal" href="#calipy.core.tensor.CalipyIndex" title="calipy.core.tensor.CalipyIndex"><em>CalipyIndex</em></a>) – The subsampling index indicating how subsampling
of the parameter is to be performed</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A CalipyTensor parameter being tracked by gradient tape and marked for 
optimization. Starts as init_tensor, has dims and constraints as specified
and is automatically subsampled by subsampling_index.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.tensor.CalipyTensor" title="calipy.core.tensor.CalipyTensor">CalipyTensor</a></p>
</dd>
</dl>
<p>Example usage: Run line by line to investigate Class</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create parameter ---------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># i) Imports and definitions</span>
<span class="kn">import</span> <span class="nn">calipy</span>
<span class="kn">from</span> <span class="nn">calipy.core.base</span> <span class="kn">import</span> <span class="n">param</span>

<span class="n">batch_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bd_1_A&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="n">event_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_1_A&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">param_dims</span> <span class="o">=</span> <span class="n">batch_dims</span> <span class="o">+</span> <span class="n">event_dims</span>
<span class="n">init_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">param_dims</span><span class="o">.</span><span class="n">sizes</span><span class="p">)</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">param_dims</span><span class="o">.</span><span class="n">sizes</span><span class="p">)</span>
<span class="n">parameter</span> <span class="o">=</span> <span class="n">param</span><span class="p">(</span><span class="s1">&#39;generic_param&#39;</span><span class="p">,</span> <span class="n">init_tensor</span><span class="p">,</span> <span class="n">param_dims</span><span class="p">)</span>

<span class="c1"># Create constrained, subsampled parameter ---------------------------</span>
<span class="c1">#</span>
<span class="n">param_constraint</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">positive</span>
<span class="n">subsample_indices</span> <span class="o">=</span> <span class="n">TensorIndexer</span><span class="o">.</span><span class="n">create_simple_subsample_indices</span><span class="p">(</span><span class="n">batch_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                        <span class="n">batch_dims</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">ssi</span> <span class="o">=</span> <span class="n">subsample_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">ssi_expanded</span> <span class="o">=</span> <span class="n">ssi</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">param_dims</span><span class="p">,</span> <span class="n">param_dims</span><span class="o">.</span><span class="n">sizes</span><span class="p">)</span>
<span class="n">parameter_subsampled</span> <span class="o">=</span> <span class="n">param</span><span class="p">(</span><span class="s1">&#39;param_subsampled&#39;</span><span class="p">,</span> <span class="n">init_tensor</span><span class="p">,</span> <span class="n">param_dims</span><span class="p">,</span>
                             <span class="n">constraint</span> <span class="o">=</span> <span class="n">param_constraint</span><span class="p">,</span> <span class="n">subsample_index</span> <span class="o">=</span> <span class="n">ssi_expanded</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">parameter_subsampled</span><span class="p">)</span>
<span class="k">assert</span><span class="p">((</span><span class="n">parameter_subsampled</span><span class="o">.</span><span class="n">tensor</span> <span class="o">-</span> <span class="n">parameter</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">ssi_expanded</span><span class="o">.</span><span class="n">tuple</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>


<span class="c1"># Investigate parameter ----------------------------------------------</span>
<span class="c1">#</span>

<span class="c1"># Parameters are CalipyTensors with names, dims, and populated indexers</span>
<span class="n">parameter</span><span class="o">.</span><span class="n">name</span>
<span class="n">parameter</span><span class="o">.</span><span class="n">dims</span>
<span class="n">parameter</span><span class="o">.</span><span class="n">indexer</span>
<span class="n">parameter</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>
<span class="n">parameter</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="o">.</span><span class="n">tensor</span>

<span class="n">parameter_subsampled</span><span class="o">.</span><span class="n">name</span>
<span class="n">parameter_subsampled</span><span class="o">.</span><span class="n">dims</span>
<span class="n">parameter_subsampled</span><span class="o">.</span><span class="n">indexer</span>
<span class="n">parameter_subsampled</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>
<span class="n">parameter_subsampled</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="o">.</span><span class="n">tensor</span>

<span class="c1"># The underlying tensors are also saved in pyro&#39;s param store</span>
<span class="n">pyro_param</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">get_param_store</span><span class="p">()[</span><span class="s1">&#39;generic_param&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">pyro_param</span> <span class="o">-</span> <span class="n">parameter</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>pyro.param doc:</p>
<p>Saves the variable as a parameter in the param store.
To interact with the param store or write to disk,
see <a class="reference external" href="parameters.html">Parameters</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – name of parameter</p></li>
<li><p><strong>init_tensor</strong> (<em>torch.Tensor</em><em> or </em><em>callable</em>) – initial tensor or lazy callable that returns a tensor.
For large tensors, it may be cheaper to write e.g.
<code class="docutils literal notranslate"><span class="pre">lambda:</span> <span class="pre">torch.randn(100000)</span></code>, which will only be evaluated on the
initial statement.</p></li>
<li><p><strong>constraint</strong> (<em>torch.distributions.constraints.Constraint</em>) – torch constraint, defaults to <code class="docutils literal notranslate"><span class="pre">constraints.real</span></code>.</p></li>
<li><p><strong>event_dim</strong> (<em>int</em>) – (optional) number of rightmost dimensions unrelated
to batching. Dimension to the left of this will be considered batch
dimensions; if the param statement is inside a subsampled plate, then
corresponding batch dimensions of the parameter will be correspondingly
subsampled. If unspecified, all dimensions will be considered event
dims and no subsampling will be performed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A constrained parameter. The underlying unconstrained parameter
is accessible via <code class="docutils literal notranslate"><span class="pre">pyro.param(...).unconstrained()</span></code>, where
<code class="docutils literal notranslate"><span class="pre">.unconstrained</span></code> is a weakref attribute.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.primitives.sample">
<span class="sig-prename descclassname"><span class="pre">calipy.core.primitives.</span></span><span class="sig-name descname"><span class="pre">sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist_dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subsample_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectorizable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.primitives.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Flexible sampling function handling multiple plates and four cases based on <cite>obs</cite> and <cite>subsample_index</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Base name for the sample site.</p></li>
<li><p><strong>dist</strong> (<em>pyro.distributions.Distribution</em>) – The distribution to sample from.</p></li>
<li><p><strong>dist_dims</strong> (<em>list</em><em> of </em><em>CalipyDim objects</em>) – The dimensions of the sample from the distribution; need to contain batch_dims as subset.</p></li>
<li><p><strong>vectorizable</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, uses vectorized sampling. If False, uses sequential sampling. Default is True.</p></li>
<li><p><strong>obs</strong> (<a class="reference internal" href="#calipy.core.data.CalipyIO" title="calipy.core.data.CalipyIO"><em>CalipyIO</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Observations wrapped in CalipyIO. If provided, sampling is conditioned on these observations.</p></li>
<li><p><strong>subsample_index</strong> (<em>list</em><em> of </em><em>torch.Tensor</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Subsample indices for each plate dimension. If provided, sampling is performed over these indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A CalipyTensor sample being tracked by gradient tape.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.tensor.CalipyTensor" title="calipy.core.tensor.CalipyTensor">CalipyTensor</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Investigate 2D noise ------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># i) Imports and definitions</span>
<span class="o">...</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="function-classes-and-functions">
<h2>Function classes and functions<a class="headerlink" href="#function-classes-and-functions" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.funs.calipy_sum">
<span class="sig-prename descclassname"><span class="pre">calipy.core.funs.</span></span><span class="sig-name descname"><span class="pre">calipy_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">calipy_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.funs.calipy_sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.funs.calipy_cat">
<span class="sig-prename descclassname"><span class="pre">calipy.core.funs.</span></span><span class="sig-name descname"><span class="pre">calipy_cat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">calipy_tensors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.funs.calipy_cat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="data-classes-and-functions">
<h2>Data classes and functions<a class="headerlink" href="#data-classes-and-functions" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.data.DataTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.data.</span></span><span class="sig-name descname"><span class="pre">DataTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.data.DataTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Custom class for holding tuples of various objects with explicit names.
Provides methods for easily distributing functions over the entries in the
tuple and thereby makes modifying collections of objects easier. This is
routinely used to perform actions on grouped observation tensors, batch_dims,
or event_dims.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>names</strong> (<em>list</em><em> of </em><em>string</em>) – A list of names serving as keys for the DataTuple.</p></li>
<li><p><strong>values</strong> (<em>list</em><em> of </em><em>obj</em>) – A list of objects serving as values for the DataTuple.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of DataTuple containing the key, value pairs and additional
attributes and methods.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.data.DataTuple" title="calipy.core.data.DataTuple">DataTuple</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create DataTuple of tensors</span>
<span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tensor_A&#39;</span><span class="p">,</span> <span class="s1">&#39;tensor_B&#39;</span><span class="p">]</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="n">data_tuple</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="n">data_tuple</span><span class="p">[</span><span class="s1">&#39;tensor_A&#39;</span><span class="p">]</span>

<span class="c1"># Apply functions</span>
<span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span><span class="mi">1</span>
<span class="n">result_tuple_1</span> <span class="o">=</span> <span class="n">data_tuple</span><span class="o">.</span><span class="n">apply_elementwise</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result of applying function:&quot;</span><span class="p">,</span> <span class="n">result_tuple_1</span><span class="p">,</span> <span class="n">result_tuple_1</span><span class="p">[</span><span class="s1">&#39;tensor_A&#39;</span><span class="p">],</span> <span class="n">result_tuple_1</span><span class="p">[</span><span class="s1">&#39;tensor_B&#39;</span><span class="p">])</span>
<span class="n">fun_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tensor_A&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;tensor_B&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
<span class="n">result_tuple_2</span> <span class="o">=</span> <span class="n">data_tuple</span><span class="o">.</span><span class="n">apply_from_dict</span><span class="p">(</span><span class="n">fun_dict</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result of applying function dictionary:&quot;</span><span class="p">,</span> <span class="n">result_tuple_2</span><span class="p">,</span> <span class="n">result_tuple_2</span><span class="p">[</span><span class="s1">&#39;tensor_A&#39;</span><span class="p">],</span> <span class="n">result_tuple_2</span><span class="p">[</span><span class="s1">&#39;tensor_B&#39;</span><span class="p">])</span>


<span class="c1"># Create DataTuple of dimensions</span>
<span class="n">batch_dims_A</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bd_A&#39;</span><span class="p">,])</span>
<span class="n">event_dims_A</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_A&#39;</span><span class="p">])</span>       
<span class="n">batch_dims_B</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bd_B&#39;</span><span class="p">])</span>
<span class="n">event_dims_B</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_B&#39;</span><span class="p">])</span>

<span class="n">batch_dims_tuple</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="n">batch_dims_A</span><span class="p">,</span> <span class="n">batch_dims_B</span><span class="p">])</span>
<span class="n">event_dims_tuple</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="n">event_dims_A</span><span class="p">,</span> <span class="n">event_dims_B</span><span class="p">])</span>

<span class="c1"># Add them </span>
<span class="n">added_tensor_tuple</span> <span class="o">=</span> <span class="n">data_tuple</span> <span class="o">+</span> <span class="n">data_tuple</span>
<span class="n">full_dims_datatuple</span> <span class="o">=</span> <span class="n">batch_dims_tuple</span> <span class="o">+</span> <span class="n">event_dims_tuple</span>

<span class="c1"># Construct indexer</span>
<span class="n">data_tuple_cp</span> <span class="o">=</span> <span class="n">data_tuple</span><span class="o">.</span><span class="n">calipytensor_construct</span><span class="p">(</span><span class="n">full_dims_datatuple</span><span class="p">)</span>
<span class="n">augmented_tensor</span> <span class="o">=</span> <span class="n">data_tuple_cp</span><span class="p">[</span><span class="s1">&#39;tensor_A&#39;</span><span class="p">]</span>
<span class="n">augmented_tensor</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>

<span class="c1"># Access subattributes</span>
<span class="n">shapes_tuple</span> <span class="o">=</span> <span class="n">data_tuple</span><span class="o">.</span><span class="n">get_subattributes</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shapes of each tensor in DataTuple:&quot;</span><span class="p">,</span> <span class="n">shapes_tuple</span><span class="p">)</span>
<span class="n">batch_dims_datatuple</span><span class="o">.</span><span class="n">get_subattributes</span><span class="p">(</span><span class="s1">&#39;sizes&#39;</span><span class="p">)</span>
<span class="n">batch_dims_datatuple</span><span class="o">.</span><span class="n">get_subattributes</span><span class="p">(</span><span class="s1">&#39;build_torchdims&#39;</span><span class="p">)</span>

<span class="c1"># Set new item</span>
<span class="n">data_tuple</span><span class="p">[</span><span class="s1">&#39;tensor_C&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data_tuple</span><span class="p">)</span>

<span class="c1"># Apply class over each element</span>
<span class="k">class</span> <span class="nc">DifferentClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">tensor</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;DifferentClass(tensor=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="si">}</span><span class="s2">)&quot;</span>

<span class="n">different_tuple</span> <span class="o">=</span> <span class="n">data_tuple</span><span class="o">.</span><span class="n">apply_class</span><span class="p">(</span><span class="n">DifferentClass</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result of applying DifferentClass to DataTuple:&quot;</span><span class="p">,</span> <span class="n">different_tuple</span><span class="p">)</span>


<span class="c1"># DataTuple and CalipyTensor interact well: In the following we showcase</span>
<span class="c1"># that a DataTuple of CalipyTensors can be subsampled by providing a</span>
<span class="c1"># DataTuple of CalipyIndexes or a single CalipyIndex that is automatically</span>
<span class="n">distributed</span> <span class="n">over</span> <span class="n">the</span> <span class="n">CalipyTensors</span> <span class="k">for</span> <span class="n">indexing</span><span class="o">.</span>

<span class="c1"># Set up DataTuple of CalipyTensors</span>
<span class="n">batch_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bd_1&#39;</span><span class="p">])</span>
<span class="n">event_dims_A</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_1_A&#39;</span><span class="p">,</span> <span class="s1">&#39;ed_2_A&#39;</span><span class="p">])</span>
<span class="n">data_dims_A</span> <span class="o">=</span> <span class="n">batch_dims</span> <span class="o">+</span> <span class="n">event_dims_A</span>
<span class="n">event_dims_B</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">(</span><span class="n">dim_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ed_1_B&#39;</span><span class="p">])</span>
<span class="n">data_dims_B</span> <span class="o">=</span> <span class="n">batch_dims</span> <span class="o">+</span> <span class="n">event_dims_B</span>
<span class="n">data_A_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">data_A_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_A_torch</span><span class="p">,</span> <span class="n">data_dims_A</span><span class="p">,</span> <span class="s1">&#39;data_A&#39;</span><span class="p">)</span>
<span class="n">data_B_torch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">data_B_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data_B_torch</span><span class="p">,</span> <span class="n">data_dims_B</span><span class="p">,</span> <span class="s1">&#39;data_B&#39;</span><span class="p">)</span>

<span class="n">data_AB_tuple</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">([</span><span class="s1">&#39;data_A_cp&#39;</span><span class="p">,</span> <span class="s1">&#39;data_B_cp&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">data_A_cp</span><span class="p">,</span> <span class="n">data_B_cp</span><span class="p">])</span>

<span class="c1"># subsample the data individually</span>
<span class="n">data_AB_subindices</span> <span class="o">=</span> <span class="n">TensorIndexer</span><span class="o">.</span><span class="n">create_simple_subsample_indices</span><span class="p">(</span><span class="n">batch_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">data_AB_subindex</span> <span class="o">=</span> <span class="n">data_AB_subindices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">data_A_subindex</span> <span class="o">=</span> <span class="n">data_AB_subindex</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">data_dims_A</span><span class="p">,</span> <span class="n">data_A_cp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">data_B_subindex</span> <span class="o">=</span> <span class="n">data_AB_subindex</span><span class="o">.</span><span class="n">expand_to_dims</span><span class="p">(</span><span class="n">data_dims_B</span><span class="p">,</span> <span class="n">data_B_cp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">data_AB_sub_1</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">([</span><span class="s1">&#39;data_A_cp_sub&#39;</span><span class="p">,</span> <span class="s1">&#39;data_B_cp_sub&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">data_A_cp</span><span class="p">[</span><span class="n">data_A_subindex</span><span class="p">],</span> <span class="n">data_B_cp</span><span class="p">[</span><span class="n">data_B_subindex</span><span class="p">]])</span>

<span class="c1"># Use subsampling functionality for DataTuples, either by passing a DataTuple of</span>
<span class="c1"># CalipyIndex or a single CalipyIndex that is broadcasted</span>
<span class="n">data_AB_subindex_tuple</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">([</span><span class="s1">&#39;data_A_cp&#39;</span><span class="p">,</span> <span class="s1">&#39;data_B_cp&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">data_A_subindex</span><span class="p">,</span> <span class="n">data_B_subindex</span><span class="p">])</span>
<span class="n">data_AB_sub_2</span> <span class="o">=</span> <span class="n">data_AB_tuple</span><span class="o">.</span><span class="n">subsample</span><span class="p">(</span><span class="n">data_AB_subindex_tuple</span><span class="p">)</span>
<span class="n">data_AB_sub_3</span> <span class="o">=</span> <span class="n">data_AB_tuple</span><span class="o">.</span><span class="n">subsample</span><span class="p">(</span><span class="n">data_AB_subindex</span><span class="p">)</span>
<span class="k">assert</span> <span class="p">((</span><span class="n">data_AB_sub_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_AB_sub_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="k">assert</span> <span class="p">((</span><span class="n">data_AB_sub_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_AB_sub_3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.data.CalipyDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.data.</span></span><span class="sig-name descname"><span class="pre">CalipyDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.data.CalipyDict" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary-like container that can store single or multiple items.
If it contains exactly one item, calipy_dict.value can be called to retrieve
it directly. Is meant as a convenient wrapper to DataTuple functionality 
and is the basis  for the standard input/output/observation format CalipyIO
handled inside of the CalipyNode objects. Is typically autowrapped around 
dictionaries or single objects provided by the user towards e.g. the forward()
method. Has idempotent property and leaves CalipyDict objects unchanged.</p>
<p>CalipyDict allows heterogeneous tensor shapes for flexible datasets. Keys
represent measurement identifiers (‘mean’, ‘var’, etc.); values are e.g. 
CalipyTensors with potentially differing shapes across CalipyDict instances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<em>None</em><em>, </em><em>dict</em><em>, </em><a class="reference internal" href="#calipy.core.data.CalipyDict" title="calipy.core.data.CalipyDict"><em>CalipyDict</em></a><em>, </em><a class="reference internal" href="#calipy.core.data.DataTuple" title="calipy.core.data.DataTuple"><em>DataTuple</em></a><em>, or </em><em>any single object.</em>) – <p>The data used to construct the CalipyDict.
Valid input types include:</p>
<ul class="simple">
<li><p><cite>None</cite>: Initializes an empty dict.</p></li>
<li><p><cite>dict[str, item]</cite>: Multi-item dictionary.</p></li>
<li><p><cite>CalipyDict</cite>: Returns unchanged.</p></li>
<li><p><cite>DataTuple</cite>: Converted to dict.</p></li>
<li><p>Single object: Stored under a default key <cite>‘__single__’</cite>.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of CalipyDict</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.data.CalipyDict" title="calipy.core.data.CalipyDict">CalipyDict</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Imports and definitions</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">calipy.core.data</span> <span class="kn">import</span> <span class="n">DataTuple</span><span class="p">,</span> <span class="n">CalipyDict</span>


<span class="c1"># Create data for CalipyDict initialization</span>
<span class="n">tensor_A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">tensor_B</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tensor_A&#39;</span><span class="p">,</span> <span class="s1">&#39;tensor_B&#39;</span><span class="p">]</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">tensor_A</span><span class="p">,</span> <span class="n">tensor_B</span><span class="p">]</span>
<span class="n">data_tuple</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="n">data_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tensor_A&#39;</span><span class="p">:</span> <span class="n">tensor_A</span><span class="p">,</span> <span class="s1">&#39;tensor_B&#39;</span> <span class="p">:</span> <span class="n">tensor_B</span><span class="p">}</span>

<span class="c1"># Create CalipyDict objects</span>
<span class="n">dict_from_none</span> <span class="o">=</span> <span class="n">CalipyDict</span><span class="p">()</span>
<span class="n">dict_from_dict</span> <span class="o">=</span> <span class="n">CalipyDict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
<span class="n">dict_from_tuple</span> <span class="o">=</span> <span class="n">CalipyDict</span><span class="p">(</span><span class="n">data_tuple</span><span class="p">)</span>
<span class="n">dict_from_calipy</span> <span class="o">=</span> <span class="n">CalipyDict</span><span class="p">(</span><span class="n">dict_from_dict</span><span class="p">)</span>
<span class="n">dict_from_single</span> <span class="o">=</span> <span class="n">CalipyDict</span><span class="p">(</span><span class="n">tensor_A</span><span class="p">)</span>

<span class="c1"># Print contents and investigate </span>
<span class="k">for</span> <span class="n">cp_dict</span> <span class="ow">in</span> <span class="p">[</span><span class="n">dict_from_none</span><span class="p">,</span> <span class="n">dict_from_dict</span><span class="p">,</span> <span class="n">dict_from_tuple</span><span class="p">,</span> 
                <span class="n">dict_from_calipy</span><span class="p">,</span> <span class="n">dict_from_single</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">cp_dict</span><span class="p">)</span>

<span class="n">dict_from_single</span><span class="o">.</span><span class="n">has_single_item</span>
<span class="n">dict_from_single</span><span class="o">.</span><span class="n">value</span>
<span class="n">dict_from_dict</span><span class="o">.</span><span class="n">as_datatuple</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.data.CalipyList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.data.</span></span><span class="sig-name descname"><span class="pre">CalipyList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.data.CalipyList" title="Permalink to this definition">¶</a></dt>
<dd><p>A list-like container that can store single or multiple dict like containers.
Is meant as a convenient wrapper for homogeneous and inhomogeneous lists of
data where each list element is a CalipyDict. CalipyList is a central element
to the standard input/output/observation format handled inside of the CalipyNode
objects. Is typically autowrapped around lists of dictionaries or single objects
provided by the user towards e.g. the forward() method. Has idempotent property
and leaves CalipyList objects unchanged; i.e. wrapping multiple times is equivalent
to wrapping once. Ingredient to CalipyIO.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<em>Any</em>) – <p>The data being used to construct the CalipyList. 
Valid input types include:</p>
<blockquote>
<div><ul class="simple">
<li><p>A single item =&gt; CalipyList containing single item</p></li>
<li><p>A list =&gt; CalipyList containg list of objects</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of CalipyList</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.data.CalipyList" title="calipy.core.data.CalipyList">CalipyList</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.data.CalipyIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.data.</span></span><span class="sig-name descname"><span class="pre">CalipyIO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'io_noname'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.data.CalipyIO" title="Permalink to this definition">¶</a></dt>
<dd><p>A data container that can store single or multiple dict like containers.
Is meant as a convenient wrapper for homogeneous and inhomogeneous lists of
data where each list element is a CalipyDict. CalipyIO s the standard input
/output/observation format handled inside of the CalipyNode objects. Is
typically autowrapped around lists of dictionaries or single objects provided
by the user towards e.g. the forward() method. Has idempotent property and 
leaves CalipyIO objects unchanged; i.e. wrapping multiple times is equivalent
to wrapping once. CalipyIO objects are also the output of iterating through
InhomogeneousDataLoader objects; i.e. datasets and subbatched datasets are
represented in this way.</p>
<dl class="simple">
<dt>Special access rules: </dt><dd><ul class="simple">
<li><p>If calipy_io contains in its list a single dict, calipy_io.dict returns it</p></li>
<li><dl class="simple">
<dt>If calipy_io contains in its list a single dict, calipy_io[key] returns</dt><dd><p>the corresponding value dict[key]</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>If calipy_io contains in its list a single dict and in that dict a single</dt><dd><p>key, value pair, then calipy_io.value returns that value.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<em>None</em><em>, or </em><em>dict</em><em>, or </em><a class="reference internal" href="#calipy.core.data.CalipyDict" title="calipy.core.data.CalipyDict"><em>CalipyDict</em></a><em>, or </em><a class="reference internal" href="#calipy.core.data.DataTuple" title="calipy.core.data.DataTuple"><em>DataTuple</em></a><em>, or </em><em>single object.</em>) – <p>The data being used to construct the CalipyDict. 
Valid input types include:</p>
<blockquote>
<div><ul class="simple">
<li><p>None =&gt; empty dict</p></li>
<li><p>A dict {str -&gt; item} =&gt; multi-item</p></li>
<li><p>A CalipyDict =&gt; Leave unchanged</p></li>
<li><p>A DataTuple =&gt; convert to dict</p></li>
<li><p>A single item =&gt; store under a default key ‘__single__’</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of CalipyDict</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.data.CalipyDict" title="calipy.core.data.CalipyDict">CalipyDict</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Imports and definitions</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">calipy.core.data</span> <span class="kn">import</span> <span class="n">DataTuple</span><span class="p">,</span> <span class="n">CalipyDict</span><span class="p">,</span> <span class="n">CalipyList</span><span class="p">,</span> <span class="n">CalipyIO</span>
<span class="kn">from</span> <span class="nn">calipy.core.tensor</span> <span class="kn">import</span> <span class="n">CalipyTensor</span>
<span class="kn">from</span> <span class="nn">calipy.core.utils</span> <span class="kn">import</span> <span class="n">dim_assignment</span>


<span class="c1"># Create data for CalipyList</span>
<span class="n">calipy_list_empty</span> <span class="o">=</span> <span class="n">CalipyList</span><span class="p">()</span>
<span class="n">calipy_list</span> <span class="o">=</span> <span class="n">CalipyList</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="n">calipy_same_list</span> <span class="o">=</span> <span class="n">CalipyList</span><span class="p">(</span><span class="n">calipy_list</span><span class="p">)</span>


<span class="c1"># Pass data into CalipyIO and investigate</span>

<span class="c1"># Legal input types are None, single object, dict, CalipyDict, DataTuple, list,</span>
<span class="c1"># CalipyList, CalipyIO. </span>

<span class="c1"># Build inputs</span>
<span class="n">none_input</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">single_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">])</span>
<span class="n">dict_input</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span> <span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="n">CalipyDict_input</span> <span class="o">=</span> <span class="n">CalipyDict</span><span class="p">(</span><span class="n">dict_input</span><span class="p">)</span>
<span class="n">DataTuple_input</span> <span class="o">=</span> <span class="n">CalipyDict_input</span><span class="o">.</span><span class="n">as_datatuple</span><span class="p">()</span>
<span class="n">list_input</span> <span class="o">=</span> <span class="p">[</span><span class="n">dict_input</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span> <span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;d&#39;</span> <span class="p">:</span> <span class="mi">4</span><span class="p">}]</span>
<span class="n">CalipyList_input</span> <span class="o">=</span> <span class="n">CalipyList</span><span class="p">(</span><span class="n">list_input</span><span class="p">)</span>
<span class="n">CalipyIO_input</span> <span class="o">=</span> <span class="n">CalipyIO</span><span class="p">(</span><span class="n">dict_input</span><span class="p">)</span>

<span class="c1"># Build CalipyIO&#39;s</span>
<span class="n">none_io</span> <span class="o">=</span> <span class="n">CalipyIO</span><span class="p">(</span><span class="n">none_input</span><span class="p">)</span>
<span class="n">single_io</span> <span class="o">=</span> <span class="n">CalipyIO</span><span class="p">(</span><span class="n">single_input</span><span class="p">)</span>
<span class="n">dict_io</span> <span class="o">=</span> <span class="n">CalipyIO</span><span class="p">(</span><span class="n">dict_input</span><span class="p">)</span>
<span class="n">CalipyDict_io</span> <span class="o">=</span> <span class="n">CalipyIO</span><span class="p">(</span><span class="n">CalipyDict_input</span><span class="p">)</span>
<span class="n">DataTuple_io</span> <span class="o">=</span> <span class="n">CalipyIO</span><span class="p">(</span><span class="n">DataTuple_input</span><span class="p">)</span>
<span class="n">list_io</span> <span class="o">=</span> <span class="n">CalipyIO</span><span class="p">(</span><span class="n">list_input</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;io_from_list&#39;</span><span class="p">)</span>
<span class="n">CalipyList_io</span> <span class="o">=</span> <span class="n">CalipyIO</span><span class="p">(</span><span class="n">CalipyList_input</span><span class="p">)</span>
<span class="n">CalipyIO_io</span> <span class="o">=</span> <span class="n">CalipyIO</span><span class="p">(</span><span class="n">CalipyIO_input</span><span class="p">)</span>


<span class="c1"># Check properties</span>
<span class="n">none_io</span><span class="o">.</span><span class="n">is_null</span>
<span class="n">single_io</span><span class="o">.</span><span class="n">is_null</span>
<span class="nb">print</span><span class="p">(</span><span class="n">single_io</span><span class="p">)</span>


<span class="c1"># Functionality includes:</span>
<span class="c1">#   1. Iteration</span>
<span class="c1">#   2. Fetch by index</span>
<span class="c1">#   3. Associated CalipyIndex</span>
<span class="c1">#      -  Has global and local index</span>
<span class="c1">#   4. Comes with collate function</span>

<span class="c1"># 1. Iteration</span>
<span class="c1"># Proceed to investigate one of the built calipy_io objects, here list_io</span>
<span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="n">list_io</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="p">)</span>

<span class="c1"># 2. Fetch by index</span>
<span class="c1"># Access values (special if list and dict only have 1 element)</span>
<span class="n">single_io</span><span class="o">.</span><span class="n">dict</span>
<span class="n">single_io</span><span class="o">.</span><span class="n">value</span>
<span class="n">single_io</span><span class="o">.</span><span class="n">calipy_dict</span>
<span class="n">single_io</span><span class="o">.</span><span class="n">calipy_list</span>
<span class="n">single_io</span><span class="o">.</span><span class="n">data_tuple</span>
<span class="n">single_io</span><span class="p">[</span><span class="s1">&#39;__single__&#39;</span><span class="p">]</span>
<span class="n">list_io</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>


<span class="c1"># 3. a) Associated Indexer</span>
<span class="c1"># Content of indexer</span>
<span class="n">list_io</span><span class="o">.</span><span class="n">batch_dim_flattened</span>
<span class="n">list_io</span><span class="o">.</span><span class="n">indexer</span>
<span class="n">list_io</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>
<span class="n">list_io_sub</span> <span class="o">=</span> <span class="n">list_io</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">list_io_sub</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">data_source_name</span>
<span class="n">list_io_sub</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">index_tensor_dims</span>

<span class="c1"># 3. b) Associated CalipyIndex</span>
<span class="c1"># Content of specific IOIndexer</span>
<span class="n">list_io_sub</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span><span class="o">.</span><span class="n">tuple</span>
<span class="n">list_io_sub</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span><span class="o">.</span><span class="n">tensor</span>
<span class="n">list_io_sub</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span><span class="o">.</span><span class="n">index_name_dict</span>

<span class="n">list_io_sub</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="o">.</span><span class="n">tuple</span>
<span class="n">list_io_sub</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="o">.</span><span class="n">tensor</span>
<span class="n">list_io_sub</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="o">.</span><span class="n">index_name_dict</span>

<span class="c1"># Iteration produces sub_io&#39;s</span>
<span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="n">list_io</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>

<span class="c1"># 3. c) Index / IO interaction</span>
<span class="c1"># subsampling and indexing: via intes, tuples, slices, and CalipyIndex</span>
<span class="n">sub_io_1</span> <span class="o">=</span> <span class="n">list_io</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">sub_io_2</span> <span class="o">=</span> <span class="n">list_io</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">sub_io_3</span> <span class="o">=</span> <span class="n">list_io</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

<span class="n">sub_io_1</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>
<span class="n">sub_io_2</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>
<span class="n">sub_io_3</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">local_index</span>

<span class="n">sub_io_1</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>
<span class="n">sub_io_2</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>
<span class="n">sub_io_3</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>

<span class="n">global_index_1</span> <span class="o">=</span> <span class="n">sub_io_1</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>
<span class="n">global_index_2</span> <span class="o">=</span> <span class="n">sub_io_2</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>
<span class="n">global_index_3</span> <span class="o">=</span> <span class="n">sub_io_3</span><span class="o">.</span><span class="n">indexer</span><span class="o">.</span><span class="n">global_index</span>

<span class="k">assert</span><span class="p">(</span><span class="n">list_io</span><span class="p">[</span><span class="n">global_index_1</span><span class="p">]</span> <span class="o">==</span> <span class="n">list_io</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span><span class="n">list_io</span><span class="p">[</span><span class="n">global_index_2</span><span class="p">]</span> <span class="o">==</span> <span class="n">list_io</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span><span class="n">list_io</span><span class="p">[</span><span class="n">global_index_3</span><span class="p">]</span> <span class="o">==</span> <span class="n">list_io</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># 4. Collate function</span>
<span class="c1"># Check collation functionality for autoreducing io s</span>
<span class="n">mean_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd_1&#39;</span><span class="p">,</span> <span class="s1">&#39;ed_1&#39;</span><span class="p">])</span>
<span class="n">var_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd_1&#39;</span><span class="p">,</span> <span class="s1">&#39;ed_1&#39;</span><span class="p">])</span>

<span class="n">mean_1</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">mean_dims</span><span class="p">)</span>
<span class="n">mean_2</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">mean_dims</span><span class="p">)</span>
<span class="n">var_1</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">var_dims</span><span class="p">)</span>
<span class="n">var_2</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">var_dims</span><span class="p">)</span>

<span class="n">io_obj</span> <span class="o">=</span> <span class="n">CalipyIO</span><span class="p">([</span>
    <span class="n">CalipyDict</span><span class="p">({</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean_1</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="n">var_1</span><span class="p">}),</span>
    <span class="n">CalipyDict</span><span class="p">({</span><span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mean_2</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="n">var_2</span><span class="p">})</span>
<span class="p">])</span>

<span class="n">collated_io</span> <span class="o">=</span> <span class="n">io_obj</span><span class="o">.</span><span class="n">reduce_list</span><span class="p">()</span>

<span class="c1"># Rename all entries in the dicts in CalipyIO</span>
<span class="n">rename_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span> <span class="p">:</span> <span class="s1">&#39;new_a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span> <span class="p">:</span> <span class="s1">&#39;new_b&#39;</span><span class="p">}</span>
<span class="n">renamed_io</span> <span class="o">=</span> <span class="n">list_io</span><span class="o">.</span><span class="n">rename_keys</span><span class="p">(</span><span class="n">rename_dict</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.data.CalipyDataset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.data.</span></span><span class="sig-name descname"><span class="pre">CalipyDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">homogeneous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.data.CalipyDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>CalipyDataset is a class mimicking the functionality of the Dataset class in
torch.utils.data but providing some streamlined prebuilt functions needed
in the context of calipy. This includes support for subsampling based on 
CalipyDict objects. Is meant to be subclassed for augmenting user specified
datasets with additional, calipy-ready functionality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_data</strong> (<em>NoneType</em><em>, </em><a class="reference internal" href="#calipy.core.tensor.CalipyTensor" title="calipy.core.tensor.CalipyTensor"><em>CalipyTensor</em></a><em>, </em><a class="reference internal" href="#calipy.core.data.CalipyDict" title="calipy.core.data.CalipyDict"><em>CalipyDict</em></a><em>, </em><a class="reference internal" href="#calipy.core.data.CalipyIO" title="calipy.core.data.CalipyIO"><em>CalipyIO</em></a>) – <p>The input_data of the dataset reflecting the inputs to 
the model that evoke the corresponding outputs. 
Valid input types include:</p>
<blockquote>
<div><ul>
<li><p>None =&gt; No input data (no input)</p></li>
<li><p>CalipyTensor =&gt; Single tensor (single input)</p></li>
<li><p>CalipyDict =&gt; Dictionary containing CalipyTensors (multiple inputs)</p></li>
<li><dl class="simple">
<dt>CalipyIO =&gt; List containing CalipyDict containing CalipyTensors </dt><dd><p>(multiple inputs, possibly of inhomogeneous shape and type)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>output_data</strong> (<em>NoneType</em><em>, </em><a class="reference internal" href="#calipy.core.tensor.CalipyTensor" title="calipy.core.tensor.CalipyTensor"><em>CalipyTensor</em></a><em>, </em><a class="reference internal" href="#calipy.core.data.CalipyDict" title="calipy.core.data.CalipyDict"><em>CalipyDict</em></a><em>, </em><a class="reference internal" href="#calipy.core.data.CalipyIO" title="calipy.core.data.CalipyIO"><em>CalipyIO</em></a>) – <p>The output_data of the dataset reflecting the outputs of 
the model evoked by the corresponding inputs.
Valid input types include:</p>
<blockquote>
<div><ul>
<li><p>None =&gt; No output data (no output)</p></li>
<li><p>CalipyTensor =&gt; Single tensor (single output)</p></li>
<li><p>CalipyDict =&gt; Dictionary containing CalipyTensors (multiple outputs)</p></li>
<li><dl class="simple">
<dt>CalipyIO =&gt; List containing CalipyDict containing CalipyTensors </dt><dd><p>(multiple inputs, possibly of inhomogeneous shape and type)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>batch_dims</strong> (<a class="reference internal" href="#calipy.core.utils.DimTuple" title="calipy.core.utils.DimTuple"><em>DimTuple</em></a>) – A DimTuple object defining the batch dimensions among 
which flattening and subsampling is performed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of CalipyDataset, suitable for accessing datasets and
passing them to DataLoader objects.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.data.CalipyDataset" title="calipy.core.data.CalipyDataset">CalipyDataset</a></p>
</dd>
</dl>
<p>The following scenarios need to be covered by the construction procedure:</p>
<blockquote>
<div><ol class="lowerroman simple">
<li><p>(Input, Ouptut) =  (None, CalipyTensor)</p></li>
<li><p>(Input, Ouptut) =  (Calipytensor, CalipyTensor)</p></li>
<li><p>(Input, Ouptut) =  (None, dict(CalipyTensor))</p></li>
<li><p>(Input, Output) = (dict(CalipyTensor), dict(CalipyTensor))</p></li>
<li><p>(Input, Ouptut) =  (None, list(dict(CalipyTensor)))</p></li>
<li><p>(Input, Output) = (list(dict(CalipyTensor)), list(dict(CalipyTensor)))</p></li>
<li><p>(Input, Output) = (None, list_mixed)</p></li>
<li><p>(Input, Output) = (list_mixed, list_mixed)</p></li>
</ol>
</div></blockquote>
<p>where list_mixed means a list of dicts with entries to keys sometimes being
None or of nonmatching shapes.</p>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># i) Imports and definitions</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">pyro</span>        
<span class="kn">from</span> <span class="nn">calipy.core.utils</span> <span class="kn">import</span> <span class="n">dim_assignment</span>
<span class="kn">from</span> <span class="nn">calipy.core.data</span> <span class="kn">import</span>  <span class="n">CalipyDataset</span><span class="p">,</span> <span class="n">io_collate</span>
<span class="kn">from</span> <span class="nn">calipy.core.tensor</span> <span class="kn">import</span> <span class="n">CalipyTensor</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>

<span class="c1"># Definitions        </span>
<span class="n">n_meas</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">n_event</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">n_subbatch</span> <span class="o">=</span> <span class="mi">7</span>


<span class="c1"># ii) Create data for dataset</span>

<span class="c1"># Set up sample distributions</span>
<span class="n">mu_true</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">sigma_true</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Sample from distributions &amp; wrap result</span>
<span class="n">data_distribution</span> <span class="o">=</span> <span class="n">pyro</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">mu_true</span><span class="p">,</span> <span class="n">sigma_true</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data_distribution</span><span class="o">.</span><span class="n">sample</span><span class="p">([</span><span class="n">n_meas</span><span class="p">,</span> <span class="n">n_event</span><span class="p">])</span>
<span class="n">data_dims</span> <span class="o">=</span> <span class="n">dim_assignment</span><span class="p">([</span><span class="s1">&#39;bd_data&#39;</span><span class="p">,</span> <span class="s1">&#39;ed_data&#39;</span><span class="p">],</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_meas</span><span class="p">,</span> <span class="n">n_event</span><span class="p">])</span>
<span class="n">data_cp</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_dims</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;data&#39;</span><span class="p">)</span>

<span class="c1"># dataset_inputs</span>
<span class="n">data_none</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">data_ct</span> <span class="o">=</span> <span class="n">data_cp</span>
<span class="n">data_cd</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">data_cp</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span> <span class="p">:</span> <span class="n">data_cp</span><span class="p">}</span>
<span class="n">data_io</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_cd</span><span class="p">,</span> <span class="n">data_cd</span><span class="p">]</span>
<span class="n">data_io_mixed</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_cd</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span> <span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span> <span class="p">:</span> <span class="n">data_cp</span><span class="p">}</span> <span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">data_cp</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">},</span> <span class="n">data_cd</span><span class="p">]</span>


<span class="c1"># iii) Build datasets</span>

<span class="c1"># Build datasets and check</span>
<span class="n">dataset_none_none</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_none</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_none</span><span class="p">)</span>
<span class="n">dataset_none_ct</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_none</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_ct</span><span class="p">)</span>
<span class="n">dataset_none_cd</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_none</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_cd</span><span class="p">)</span>
<span class="n">dataset_none_io</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_none</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_io</span><span class="p">)</span>
<span class="n">dataset_none_iomixed</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_none</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_io_mixed</span><span class="p">)</span>

<span class="n">dataset_ct_ct</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_ct</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_ct</span><span class="p">)</span>
<span class="n">dataset_ct_cd</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_ct</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_cd</span><span class="p">)</span>
<span class="n">dataset_ct_io</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_ct</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_io</span><span class="p">)</span>
<span class="n">dataset_ct_iomixed</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_ct</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_io_mixed</span><span class="p">)</span>

<span class="n">dataset_cd_ct</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_cd</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_ct</span><span class="p">)</span>
<span class="n">dataset_cd_cd</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_cd</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_cd</span><span class="p">)</span>
<span class="n">dataset_cd_io</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_cd</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_io</span><span class="p">)</span>
<span class="n">dataset_cd_iomixed</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_cd</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_io_mixed</span><span class="p">)</span>

<span class="n">dataset_io_ct</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_io</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_ct</span><span class="p">)</span>
<span class="n">dataset_io_cd</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_io</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_cd</span><span class="p">)</span>
<span class="n">dataset_io_io</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_io</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_io</span><span class="p">)</span>
<span class="n">dataset_io_iomixed</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_io</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_io_mixed</span><span class="p">)</span>

<span class="n">dataset_iomixed_ct</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_io_mixed</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_ct</span><span class="p">)</span>
<span class="n">dataset_iomixed_cd</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_io_mixed</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_cd</span><span class="p">)</span>
<span class="n">dataset_iomixed_io</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_io_mixed</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_io</span><span class="p">)</span>
<span class="n">dataset_iomixed_iomixed</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="n">data_io_mixed</span><span class="p">,</span> <span class="n">output_data</span> <span class="o">=</span> <span class="n">data_io_mixed</span><span class="p">)</span>


<span class="c1"># iv) Build dataloader and subsample</span>

<span class="n">dataset</span> <span class="o">=</span> <span class="n">CalipyDataset</span><span class="p">(</span><span class="n">input_data</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_ct</span><span class="p">,</span> <span class="n">data_cd</span><span class="p">],</span>
                        <span class="n">output_data</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_ct</span><span class="p">,</span> <span class="n">data_cd</span><span class="p">]</span> <span class="p">)</span>
<span class="n">dataloader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">collate_fn</span><span class="o">=</span><span class="n">io_collate</span><span class="p">)</span>

<span class="c1"># Iterate through the DataLoader</span>
<span class="k">for</span> <span class="n">batch_input</span><span class="p">,</span> <span class="n">batch_output</span><span class="p">,</span> <span class="n">batch_index</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">batch_input</span><span class="p">,</span> <span class="n">batch_output</span><span class="p">,</span> <span class="n">batch_index</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.data.io_collate">
<span class="sig-prename descclassname"><span class="pre">calipy.core.data.</span></span><span class="sig-name descname"><span class="pre">io_collate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.data.io_collate" title="Permalink to this definition">¶</a></dt>
<dd><p>Custom collate function that collates ios together by concatenating contained
list elements into a longer list aroung which a new new CalipyIO object is built.
This new CalipyIO object contains a list of dicts.
If reduce = True, list elements are aimed to be stacked themselves (e.g. tensors
along their first dimensions) to create a single dict containing stacked elements.
Used primarily as collate function for the DataLoader to perform automatized subsampling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>batch</strong> (<em>list</em><em> of </em><a class="reference internal" href="#calipy.core.data.CalipyIO" title="calipy.core.data.CalipyIO"><em>CalipyIO</em></a>) – A list of CalipyDiIO containing info on input_vars, observations, and
corresponding index that was used to produce them via dataset.__getitem__[idx]</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of CalipyIO, where multiple CalipyDict objects are 
collated together either into a list of dicts or into a single calipy_io
containing stacked CalipyTensors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#calipy.core.data.CalipyIO" title="calipy.core.data.CalipyIO">CalipyIO</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.data.preprocess_args">
<span class="sig-prename descclassname"><span class="pre">calipy.core.data.</span></span><span class="sig-name descname"><span class="pre">preprocess_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_vars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subsample_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.data.preprocess_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for preprocessing arguments to forward passes. Converts different
forms of input to CalipyIO objects reflecting a standardized form of inputs
and outputs. Typically just wraps input into CalipyIO.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_vars</strong> (<em>None</em><em>, </em><em>single object</em><em>, </em><em>Dict</em><em>, </em><a class="reference internal" href="#calipy.core.data.CalipyDict" title="calipy.core.data.CalipyDict"><em>CalipyDict</em></a><em>, </em><em>list</em><em>, </em><a class="reference internal" href="#calipy.core.data.CalipyList" title="calipy.core.data.CalipyList"><em>CalipyList</em></a><em>, 
or </em><em>CalipyIO containing CalipyTensors.</em>) – Input input_vars to some .forward() method call. Specific
contents depend on the node but typically None or a dict containing CalipyTensors
with keys as specified in the nodes’ input_vars_schema</p></li>
<li><p><strong>observation</strong> – Input observation to some .forward() method call. Specific
contents depend on the node but typically a dict containing CalipyTensors
with keys as specified in the nodes’ observation_schema</p></li>
<li><p><strong>sbsample_index</strong> – Input subsample_index to some .forward() method call. Specific
contents depend on the node but typically None if no subsampling happens
or of type Dict containing CalipyIndex objects in case of subsampling. 
The keys are as specified in the nodes’ subsampling_schema</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing instances of CalipyIO that represent input_vars,
observations, subsample_index in a way that forward methods can handle
them well and they are easily passable between nodes.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple of <a class="reference internal" href="#calipy.core.data.CalipyIO" title="calipy.core.data.CalipyIO">CalipyIO</a></p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Imports and definitions</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">calipy.core.data</span> <span class="kn">import</span> <span class="n">DataTuple</span><span class="p">,</span> <span class="n">CalipyDict</span><span class="p">,</span> <span class="n">CalipyList</span><span class="p">,</span> <span class="n">CalipyIO</span>
<span class="kn">from</span> <span class="nn">calipy.core.tensor</span> <span class="kn">import</span> <span class="n">CalipyTensor</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="distribution-classes-and-functions">
<h2>Distribution classes and functions<a class="headerlink" href="#distribution-classes-and-functions" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="calipy.core.dist.distributions.CalipyDistribution">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">calipy.core.dist.distributions.</span></span><span class="sig-name descname"><span class="pre">CalipyDistribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_structure</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.dist.distributions.CalipyDistribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all auto-generated Calipy distributions. It wraps a Pyro 
distribution class and associates a NodeStructure (or any additional 
dimension-aware info). CalipyDistributions are Subclasses of CalipyNode and
therefore come together with a method forward(input_vars, observations, 
subsample_index, **kwargs) method. The forward() method of distributions can
be seen as a way of passing parameters and sampling; the format of inputs 
and observations is documented within the methods create_input_vars or 
create_observations that help turn data into the DataTuples needed as input
for .forward(). Al CalipyDistributions come with a default_nodestructure
consisting of just batch_dims and event_dims being a single dimension with
either size 10 or 2.</p>
<p>CalipyDistribution is not usually called by the user, it is called by an
script __init__.py in calipy.core.dist automatically executed during package
import. The subclasses of CalipyDistribution are e.g. CalipyDistribution.Normal
or CalipyDistribution.Gamma which can be accessed via calipy.core.dist.Normal
or calipy.core.dist.Gamma</p>
<p>Example usage: Run line by line to investigate Class</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># CalipyDistribution objects are CalipyNodes --------------------------</span>
<span class="c1">#</span>
<span class="c1"># i) Imports and definitions</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">calipy</span>
<span class="kn">from</span> <span class="nn">calipy.core.base</span> <span class="kn">import</span> <span class="n">NodeStructure</span>
<span class="kn">from</span> <span class="nn">calipy.core.tensor</span> <span class="kn">import</span> <span class="n">CalipyTensor</span>
<span class="kn">from</span> <span class="nn">calipy.core.data</span> <span class="kn">import</span> <span class="n">DataTuple</span>
<span class="c1">#</span>
<span class="c1"># ii) Invoke and investigate CalipyDistribution</span>
<span class="n">CalipyNormal</span> <span class="o">=</span> <span class="n">calipy</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">Normal</span>
<span class="n">CalipyNormal</span><span class="o">.</span><span class="n">dists</span>
<span class="n">CalipyNormal</span><span class="o">.</span><span class="n">input_vars</span>
<span class="n">CalipyNormal</span><span class="o">.</span><span class="n">input_vars_schema</span>

<span class="c1"># iii) Build a concrete Node</span>
<span class="n">normal_ns</span> <span class="o">=</span> <span class="n">NodeStructure</span><span class="p">(</span><span class="n">CalipyNormal</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">normal_ns</span><span class="p">)</span>
<span class="n">calipy_normal</span> <span class="o">=</span> <span class="n">CalipyNormal</span><span class="p">(</span><span class="n">node_structure</span> <span class="o">=</span> <span class="n">normal_ns</span><span class="p">,</span> <span class="n">node_name</span> <span class="o">=</span> <span class="s1">&#39;Normal&#39;</span><span class="p">)</span>

<span class="n">calipy_normal</span><span class="o">.</span><span class="n">id</span>
<span class="n">calipy_normal</span><span class="o">.</span><span class="n">node_structure</span>
<span class="n">CalipyNormal</span><span class="o">.</span><span class="n">default_nodestructure</span>

<span class="c1"># Calling the forward method</span>
<span class="n">normal_dims</span> <span class="o">=</span> <span class="n">normal_ns</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="s1">&#39;batch_dims&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">normal_ns</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="s1">&#39;event_dims&#39;</span><span class="p">]</span>
<span class="n">normal_ns_sizes</span> <span class="o">=</span> <span class="n">normal_dims</span><span class="o">.</span><span class="n">sizes</span>
<span class="n">mean</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">normal_ns_sizes</span><span class="p">),</span> <span class="n">normal_dims</span><span class="p">)</span>
<span class="n">standard_deviation</span> <span class="o">=</span> <span class="n">CalipyTensor</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">normal_ns_sizes</span><span class="p">),</span> <span class="n">normal_dims</span><span class="p">)</span>
<span class="n">input_vars_normal</span> <span class="o">=</span> <span class="n">DataTuple</span><span class="p">([</span><span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">mean</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">])</span>
<span class="n">samples_normal</span> <span class="o">=</span> <span class="n">calipy_normal</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">input_vars_normal</span><span class="p">)</span>
<span class="n">samples_normal</span>
<span class="n">samples_normal</span><span class="o">.</span><span class="n">dims</span>

<span class="c1"># A more convenient way of creating the input_vars and observations data or</span>
<span class="c1"># at least getting the info on the input signatures</span>
<span class="n">create_input_vars</span> <span class="o">=</span> <span class="n">CalipyNormal</span><span class="o">.</span><span class="n">create_input_vars</span>
<span class="n">help</span><span class="p">(</span><span class="n">create_input_vars</span><span class="p">)</span>
<span class="n">input_vars_normal_alt</span> <span class="o">=</span> <span class="n">create_input_vars</span><span class="p">(</span><span class="n">loc</span> <span class="o">=</span> <span class="n">mean</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">standard_deviation</span><span class="p">)</span>
<span class="n">samples_normal_alt</span> <span class="o">=</span> <span class="n">calipy_normal</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">input_vars_normal_alt</span><span class="p">)</span>

<span class="c1"># Since distributions are nodes, we can illustrate them</span>
<span class="n">calipy_normal</span><span class="o">.</span><span class="n">dtype_chain</span>
<span class="n">calipy_normal</span><span class="o">.</span><span class="n">id</span>
<span class="n">render_1</span> <span class="o">=</span> <span class="n">calipy_normal</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">input_vars_normal</span><span class="p">)</span>
<span class="n">render_1</span>
<span class="n">render_2</span> <span class="o">=</span> <span class="n">calipy_normal</span><span class="o">.</span><span class="n">render_comp_graph</span><span class="p">(</span><span class="n">input_vars_normal</span><span class="p">)</span>
<span class="n">render_2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="calipy.core.dist.distributions.build_default_nodestructure">
<span class="sig-prename descclassname"><span class="pre">calipy.core.dist.distributions.</span></span><span class="sig-name descname"><span class="pre">build_default_nodestructure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#calipy.core.dist.distributions.build_default_nodestructure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Usage</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#basic-classes">Basic classes</a><ul>
<li><a class="reference internal" href="#calipy.core.base.CalipyNode"><code class="docutils literal notranslate"><span class="pre">CalipyNode</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.base.NodeStructure"><code class="docutils literal notranslate"><span class="pre">NodeStructure</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.base.CalipyProbModel"><code class="docutils literal notranslate"><span class="pre">CalipyProbModel</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#effect-classes">Effect classes</a><ul>
<li><a class="reference internal" href="#calipy.core.effects.CalipyEffect"><code class="docutils literal notranslate"><span class="pre">CalipyEffect</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.effects.CalipyQuantity"><code class="docutils literal notranslate"><span class="pre">CalipyQuantity</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.effects.UnknownParameter"><code class="docutils literal notranslate"><span class="pre">UnknownParameter</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.effects.UnknownVariance"><code class="docutils literal notranslate"><span class="pre">UnknownVariance</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.effects.NoiseAddition"><code class="docutils literal notranslate"><span class="pre">NoiseAddition</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#utility-classes-and-functions">Utility classes and functions</a><ul>
<li><a class="reference internal" href="#calipy.core.utils.multi_unsqueeze"><code class="docutils literal notranslate"><span class="pre">multi_unsqueeze()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.utils.robust_meshgrid"><code class="docutils literal notranslate"><span class="pre">robust_meshgrid()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.utils.ensure_tuple"><code class="docutils literal notranslate"><span class="pre">ensure_tuple()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.utils.get_params"><code class="docutils literal notranslate"><span class="pre">get_params()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.utils.format_mro"><code class="docutils literal notranslate"><span class="pre">format_mro()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.utils.check_schema"><code class="docutils literal notranslate"><span class="pre">check_schema()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.utils.dim_assignment"><code class="docutils literal notranslate"><span class="pre">dim_assignment()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.utils.generate_trivial_dims"><code class="docutils literal notranslate"><span class="pre">generate_trivial_dims()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.utils.CalipyDim"><code class="docutils literal notranslate"><span class="pre">CalipyDim</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.utils.TorchdimTuple"><code class="docutils literal notranslate"><span class="pre">TorchdimTuple</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.utils.DimTuple"><code class="docutils literal notranslate"><span class="pre">DimTuple</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#tensor-classes-and-functions">Tensor classes and functions</a><ul>
<li><a class="reference internal" href="#calipy.core.tensor.CalipyIndex"><code class="docutils literal notranslate"><span class="pre">CalipyIndex</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.tensor.CalipyIndexer"><code class="docutils literal notranslate"><span class="pre">CalipyIndexer</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.tensor.IOIndexer"><code class="docutils literal notranslate"><span class="pre">IOIndexer</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.tensor.TensorIndexer"><code class="docutils literal notranslate"><span class="pre">TensorIndexer</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.tensor.CalipyTensor"><code class="docutils literal notranslate"><span class="pre">CalipyTensor</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.tensor.preprocess_args"><code class="docutils literal notranslate"><span class="pre">preprocess_args()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.tensor.build_dim_supersequence"><code class="docutils literal notranslate"><span class="pre">build_dim_supersequence()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.tensor._is_subsequence"><code class="docutils literal notranslate"><span class="pre">_is_subsequence()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.tensor.broadcast_dims"><code class="docutils literal notranslate"><span class="pre">broadcast_dims()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#primitive-classes-and-functions">Primitive classes and functions</a><ul>
<li><a class="reference internal" href="#calipy.core.primitives.param"><code class="docutils literal notranslate"><span class="pre">param()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.primitives.sample"><code class="docutils literal notranslate"><span class="pre">sample()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#function-classes-and-functions">Function classes and functions</a><ul>
<li><a class="reference internal" href="#calipy.core.funs.calipy_sum"><code class="docutils literal notranslate"><span class="pre">calipy_sum()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.funs.calipy_cat"><code class="docutils literal notranslate"><span class="pre">calipy_cat()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-classes-and-functions">Data classes and functions</a><ul>
<li><a class="reference internal" href="#calipy.core.data.DataTuple"><code class="docutils literal notranslate"><span class="pre">DataTuple</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.data.CalipyDict"><code class="docutils literal notranslate"><span class="pre">CalipyDict</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.data.CalipyList"><code class="docutils literal notranslate"><span class="pre">CalipyList</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.data.CalipyIO"><code class="docutils literal notranslate"><span class="pre">CalipyIO</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.data.CalipyDataset"><code class="docutils literal notranslate"><span class="pre">CalipyDataset</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.data.io_collate"><code class="docutils literal notranslate"><span class="pre">io_collate()</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.data.preprocess_args"><code class="docutils literal notranslate"><span class="pre">preprocess_args()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#distribution-classes-and-functions">Distribution classes and functions</a><ul>
<li><a class="reference internal" href="#calipy.core.dist.distributions.CalipyDistribution"><code class="docutils literal notranslate"><span class="pre">CalipyDistribution</span></code></a></li>
<li><a class="reference internal" href="#calipy.core.dist.distributions.build_default_nodestructure"><code class="docutils literal notranslate"><span class="pre">build_default_nodestructure()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/usage.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">calipy 0.5 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Usage</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Dr. Jemil Avers Butt.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.1.2.
    </div>
  </body>
</html>